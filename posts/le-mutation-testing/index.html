<!DOCTYPE html>
<html><meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>LE MUTATION TESTING Â· Blog: Romain Berthon</title>



<link rel="stylesheet" href="/css/rocinante.css" />
<link rel="shortcut icon" href="favicon.ico">


<body>
    <header><h2>
  
    <a href="https://romaintrm.github.io/">â€¹ Blog: Romain Berthon</a>
  
</h2>
</header>
    <main>

    <div class="post">
        <div class="title-group">
            <div class="title">
                <h1>LE MUTATION TESTING</h1>
            </div>
            <div class="date"><h5>Jul 26, 2016</h5></div>
        </div>
        <article class="content">
            <p>Jâ€™ai rÃ©cemment lu un <a href="http://blog.cleancoder.com/uncle-bob/2016/06/10/MutationTesting.html" target="_blank">article</a> de lâ€™<a href="https://twitter.com/unclebobmartin" target="_blank">oncle Bob Martin</a>, il y expose sa dÃ©couverte du <em>mutation testing</em> et semble trÃ¨s enthousiaste Ã  ce sujet. Jâ€™ai donc dÃ©cidÃ© dâ€™essayer un outil pour mieux comprendre cette dÃ©marche.</p>
<h2 id="le-principe">LE PRINCIPE</h2>
<p>Aujourdâ€™hui, beaucoup de projets sont rÃ©alisÃ©s en appliquant le TDD. DÃ©velopper en appliquant le <em>test first</em> permet dâ€™Ãªtre sÃ»r que lâ€™on Ã©crit uniquement le code nÃ©cessaire pour rendre un test valide.</p>
<p>Cependant, certains reprochent Ã  cette mÃ©thode de mettre en Ã©vidence la prÃ©sence de bugs, et non de dÃ©montrer lâ€™absence de bugÂ : un test qui Ã©choue montre quâ€™il y a une anomalie, mais une anomalie peut exister sans quâ€™il nâ€™y ait de test pour le montrer.</p>
<p>Lâ€™idÃ©e du <em>mutation testing</em> est de crÃ©er des mutations sur le code testÃ©. Un outil analyse le code couvert par les tests puis gÃ©nÃ¨re des mutantsÂ : Mes tests sont-ils toujours vrais si je modifie cette conditionÂ ? Et si je ne fais pas dâ€™appel Ã  cette fonctionÂ ? Un mutant peut avoir deux Ã©tatsÂ : mort ou vivant.</p>
<p>Les mutations peuvent prendre diverses formesÂ : la modification dâ€™une limite conditionnelle (&lt; devient &lt;=), lâ€™inversion dâ€™une condition (== devientÂ !=), la suppression dâ€™un appel Ã  une mÃ©thode, etc.</p>
<p>Un mutant mort montre quâ€™au moins un test Ã©choue si lâ€™on modifie le code, on peut donc en dÃ©duire que les tests protÃ¨gent bien le code contre les rÃ©gressions. Un mutant vivant montre que tous les tests passent malgrÃ© une modification du code. Le <em>mutation testing</em> peut ainsi rÃ©vÃ©ler que le code est mal protÃ©gÃ© contre les rÃ©gressions, il peut sâ€™agir dâ€™un problÃ¨me de design ou alors câ€™est la qualitÃ© des tests qui peut Ãªtre remise en cause.</p>
<h2 id="exemple">EXEMPLE</h2>
<p>Pour mon exemple, jâ€™utilise VisualMutator qui sâ€™intÃ¨gre directement dans visual studio.</p>
<h3 id="cas-initial">CAS INITIAL</h3>
<p>Ici, je teste de maniÃ¨re laxiste une simple mÃ©thode qui me dit si mon objet Sequence contient un seul Ã©lÃ©ment. Voici une premiÃ¨re solutionÂ :</p>
<p><img src="1.png" alt="Code sous tests"></p>
<p><img src="2.png" alt="Code de tests"></p>
<h2 id="mutations">MUTATIONS</h2>
<p>AprÃ¨s une premiÃ¨re session de mutation sur mon code on constate des faiblesses dans mes testsÂ :</p>
<p><img src="3.png" alt="Test runner avec un mutant vivant"></p>
<p>Le mutant <code>LessThanOrEqual</code> me montre que je peux modifier ma condition tout en gardant mes tests valides. Je le constate bien si jâ€™applique cette modification (&lt; 2 devient &lt;= 2).</p>
<p><img src="4.png" alt="Code sous tests mutÃ©"></p>
<p>Je peux ici rejeter la faute Ã  mon dernier test qui fournit une liste de trois objets. Une fois corrigÃ© je peux relancer un test par mutationÂ :</p>
<p><img src="5.png" alt="Code de test corrigÃ©"></p>
<p><img src="6.png" alt="Test runner avec un nouveau mutant vivant"></p>
<p>On constate bien cette fois que la mutation <code>LessThanOrEqual</code> nâ€™est plus vivante. Mais cette fois ci le mutant <code>NotEquality</code> reste vivant, il me manque donc clairement un test.</p>
<p><img src="7.png" alt="Code de test avec le test manquant"></p>
<p>Cette fois ci je constate que mes mutants <code>LessThanOrEqual</code> et <code>NotEquality</code> sont tous les deux tuÃ©s par mes tests.</p>
<p><img src="8.png" alt="Test runner sans mutant vivant"></p>
<h2 id="lutilitÃ©">Lâ€™UTILITÃ‰</h2>
<p>Cette approche est clairement faite pour tester la robustesse des tests plus que le code en lui mÃªme. Elle permet de mettre en Ã©vidence les limites de notre jeu de tests, et ainsi la prÃ©sence de potentielles anomalies non identifiÃ©es. En dâ€™autres termesÂ : Est-ce que je peux faire confiance Ã  mes testsÂ ?</p>
<p>Je ne suis donc pas convaincu que le <em>mutation testing</em> apporte une grande plus-value si le TDD est appliquÃ© avec rigueur. Jâ€™avoue ne pas avoir su produire de mutant vivant sur un premier exemple Ã©crit de cette maniÃ¨re.</p>
<p>Cette approche est donc beaucoup plus intÃ©ressante pour la gestion de legacy. Avant dâ€™y apporter des modifications, mieux vaut Ã©crire des tests pour se protÃ©ger contre les rÃ©gressions. Nâ€™importe quel dÃ©veloppeur ayant rÃ©alisÃ© cet exercice sait quâ€™il sâ€™agit dâ€™une tÃ¢che complexe et quâ€™il est parfois difficile dâ€™identifier tous les cas gÃ©rÃ©s. Utiliser le <em>mutation testing</em> peut facilement mettre en Ã©vidence ces cas non identifiÃ©s.</p>
<h2 id="linconvÃ©nient">Lâ€™INCONVÃ‰NIENT</h2>
<p>Il faut tout de mÃªme avoir conscience que cette mÃ©thode se rÃ©vÃ¨le extrÃªmement coÃ»teuse comparÃ©e Ã  de simples tests unitaires. Il faut considÃ©rer le temps passÃ© Ã  lâ€™analyse du code, Ã  la gÃ©nÃ©ration des mutants, ainsi quâ€™Ã  lâ€™exÃ©cution des tests pour chaque mutant, ce qui peut prendre plusieurs heures sur un projet consÃ©quent.</p>
<p>De maniÃ¨re grossiÃ¨re, imaginons un projet de 200 classes avec en moyenne 5 mutants par classe et un jeu de tests complet qui est exÃ©cutÃ© en 30 secondes. On obtientÂ :</p>
<p><strong>200 * 5 * 0.5 = 8h20 (500 minutes)</strong></p>
<p>Les tests utilisant la mutation ne peuvent donc pas Ãªtre jouÃ©s de maniÃ¨re systÃ©matique comme le sont les TUs. Il est selon moi beaucoup plus intÃ©ressant de lâ€™appliquer de maniÃ¨re ponctuelle sur des rÃ©gions ciblÃ©es du code.</p>
<p>Merci Ã  <a href="https://twitter.com/nadegerouelle" target="_blank">NadÃ¨ge</a> pour sa relecture.</p>
<hr>
<h2 id="commentaires">COMMENTAIRES</h2>
<p>Envie de commenter ? Sâ€™il vous plaÃ®t, ajoutez votre commentaire en m&rsquo;<a href="https://github.com/RomainTrm/Blog?tab=readme-ov-file#how-to-comment" target="_blank">envoyant une pull request</a>.</p>

        </article>
        
            <div class="tags">
                <span title="Tags">ğŸ·</span>
                <div class="horizontal-links links">
                    <a href="/tags/post/">Post</a><a href="/tags/fr/">Fr</a>
                </div>
            </div>
        
    </article>


    </main>
    <footer>
  <div class="content-container">
    <div class="content">Software developer, *DD and F# enthusiast


  <p class="horizontal-links"><a href="https://github.com/RomainTrm"
        target="_blank" 
       
      >Github</a><a href="https://bsky.app/profile/romaintrm.bsky.social"
        target="_blank" 
       
      >Bsky</a><a href="https://fr.linkedin.com/in/romain-berthon-254977101"
        target="_blank" 
       
      >LinkedIn</a></p>

</div>
  </div>
</footer>
    
    <script>
      const emailId = atob("");
    </script></body>
</html>
