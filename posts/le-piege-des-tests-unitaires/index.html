<!doctype html><html><meta charset=utf-8><meta http-equiv=Content-Security-Policy content="default-src 'none'; script-src 'none'; style-src 'self' 'sha256-hevimW2qBMcsaZR62OkETyNJKvnMSjRYOz6kIyvEFtg='; img-src 'self'; connect-src 'self'; base-uri 'self'; manifest-src 'self'; media-src 'self'"><meta http-equiv=Strict-Transport-Security content="max-age=63072000; includeSubDomains; preload"><meta http-equiv=X-Content-Type-Options content="nosniff"><meta http-equiv=Referrer-Policy content="strict-origin-when-cross-origin"><meta name=viewport content="width=device-width,initial-scale=1"><title>Le piÃ¨ge des tests unitaires Â· Romain Berthon</title>
<link rel=stylesheet href=/css/rocinante.css><link rel="shortcut icon" href=https://berthon.dev//favicon.ico><body><header><nav><a class=home href=https://berthon.dev/>â€¹ Home</a><div></div><div><a href=https://berthon.dev//tags/post>Posts</a>
<a href=https://berthon.dev//tags/talk>Talks</a>
<a href=https://berthon.dev//about>About</a></div></nav></header><main><div class=post><div class=title-group><div class=title><h1>Le piÃ¨ge des tests unitaires</h1></div><div class=date><h5>Jun 04, 2020</h5></div></div><article class=content><p>VoilÃ  maintenant plus de 5 ans que jâ€™applique une approche TDD (test-driven development) sur lâ€™ensemble des projets sur lesquels jâ€™interviens. Si jâ€™utilise toujours cette mÃ©thode, câ€™est parce que la prÃ©sence de tests me donne confiance dans le code que jâ€™Ã©crisÂ :</p><ul><li>Je mâ€™assure quâ€™il fait bien ce que je souhaite.</li><li>Jâ€™amÃ©liore constamment son design par du refactoring.</li><li>Les tests mettent en lumiÃ¨re la trÃ¨s grande majoritÃ© des rÃ©gressions que je peux introduire lors dâ€™un refactoring ou dâ€™une Ã©volution.</li><li>Je rÃ©duis ma charge cognitive et me focalise sur le cas mÃ©tier que je suis entrain de traiter (les tests sâ€™occupent de vÃ©rifier les autres cas pour moi).</li></ul><p>Modifier mon code est donc une capacitÃ© permise grÃ¢ce aux tests et que je souhaite conserver tout au long dâ€™un projetÂ : je peux amÃ©liorer son design pour le garder constamment adaptÃ© aux problÃ¨mes mÃ©tier que je veux rÃ©soudre.</p><p>Avec le temps, je rÃ©alise quâ€™Ã©crire des tests est une discipline difficile et que certaines pratiques peuvent Ãªtre dommageables. Les tests unitaires â€œfigentâ€ le code et mâ€™empÃªchent de le modifier facilement, ce qui peut sembler paradoxal puisquâ€™ils sont censÃ©s au contraire me le permettre.</p><p>Dans cet article, je vais essayer de mettre en lumiÃ¨re les raisons de cette dÃ©rive. Attention, mon propos ne sera pas focalisÃ© sur la pratique du TDD mais sur les tests unitaires (TU) et la maniÃ¨re dont ils influencent notre capacitÃ© Ã  modifier du code.</p><h2 id=Ã©cris-une-classe-Ã©cris-une-classe-de-tests>Ã‰cris une classe, Ã©cris une classe de tests</h2><p>Ã€ chaque classe, chaque mÃ©thode son ou ses testsÂ : Câ€™est une dÃ©finition du TU qui semble trÃ¨s rÃ©pandue, je la rencontre beaucoup au cours de discussions avec dâ€™autres dÃ©veloppeurs, sur twitter, dans des articles de blog, etc. Câ€™est mÃªme de cette maniÃ¨re que lâ€™on mâ€™a initiÃ© au TDD.</p><p>Il est vrai que câ€™est une faÃ§on simple dâ€™Ã©crire un test. Le pÃ©rimÃ¨tre que lâ€™on souhaite tester est petit, avec un nombre de dÃ©pendances normalement raisonnable. Câ€™est une approche vers laquelle on peut facilement se tourner lorsque lâ€™on nâ€™est pas Ã  lâ€™aise avec la rÃ©daction de TU.</p><p>Cette pratique est souvent associÃ©e Ã  lâ€™injection de dÃ©pendance pour fonctionner. Câ€™est Ã  ce moment-lÃ  que lâ€™on commence Ã  introduire des mocks, on peut ainsi spÃ©cifier le comportement dâ€™une dÃ©pendance sans dÃ©pendre de sa vÃ©ritable implÃ©mentation. Notre classe/mÃ©thode reste donc bien isolÃ©e du reste du systÃ¨me lors du test.</p><p>Mon point doit peut-Ãªtre vous dÃ©rangerÂ : pourquoi vouloir absolument tester en isolement une classe qui de toute faÃ§on dÃ©pend dâ€™autres classesÂ ? Le comportement de la dÃ©pendance correspondra-t-il Ã  celui que jâ€™ai spÃ©cifiÃ© avec mon mockÂ ?</p><p>Certains vous rÃ©pondront quâ€™il vous faut Ã©galement des tests dâ€™intÃ©grations. Afin de vÃ©rifier que les diffÃ©rents Ã©lÃ©ments du systÃ¨me interagissent de la bonne maniÃ¨re, et que le logiciel retourne le rÃ©sultat attendu.</p><h2 id=vous-avez-dÃ©jÃ -perdu>Vous avez dÃ©jÃ  perdu</h2><p>Si vous adoptez cette stratÃ©gie, vous allez surement souffrir, ou souffrez dÃ©jÃ , dâ€™une forte adhÃ©rence entre votre code et vos tests. En effet, il existe une contrainte forte pour chaque Ã©lÃ©ment de votre systÃ¨meÂ : des tests.</p><p>Cela signifie quâ€™Ã  chaque signature de mÃ©thode que lâ€™on veut changer, en plus du code lâ€™appelant, il va falloir corriger les tests et les mocks qui lui sont associÃ©s. Nous avons donc perdu notre capacitÃ© Ã  facilement modifier/refactorer notre code. Jâ€™ai encore le souvenir (douloureux) de journÃ©es complÃ¨tes Ã  â€œrÃ©parer les testsâ€ suite Ã  des modifications.</p><p>Ajoutez Ã  cela un biais dont nous souffrons tousÂ : celui des coÃ»ts irrÃ©cupÃ©rables. Alors quâ€™un test ne fait peut-Ãªtre plus sens, nous avons tendance (consciemment ou non) Ã  vouloir le conserver et le modifier, ceci uniquement parce quâ€™il est dÃ©jÃ  Ã©crit.</p><p>Vous lâ€™avez compris, aligner de maniÃ¨re aussi systÃ©matique ses tests avec son implÃ©mentation gÃ©nÃ¨re un couplage important contre lequel vous luttez Ã  chaque modification que vous souhaitez apporter.</p><h2 id=du-coup-comment-fait-onnbsp>Du coup, comment fait-onÂ ?</h2><p>Les TU impliquent obligatoirement un couplage avec le code. MÃªme sâ€™il existe des techniques pour le limiter, la premiÃ¨re question quâ€™il faut se poser estÂ : Ã  quoi veut-on se couplerÂ ?</p><p>De maniÃ¨re caricaturale, si vous travaillez sur des logiciels business, ce que lâ€™on attend de vous est de dÃ©velopper des use cases. Ceux-ci sont des comportements que lâ€™on attend de lâ€™application, et il fait sens de vouloir les tester. Ces use cases peuvent Ãªtre implÃ©mentÃ©s en une seule classe, ou en plusieurs. Ce sont des choix de design qui vous reviennent, mais aussi des dÃ©tails dâ€™implÃ©mentation que lâ€™on veut pouvoir facilement changer et quâ€™un observateur externe du systÃ¨me doit ignorer.</p><p>Clairement, la stratÃ©gie que lâ€™on vient dâ€™explorer sâ€™attache beaucoup Ã  ces dÃ©tails dâ€™implÃ©mentation. Unitaire ne doit donc pas dÃ©finir la taille de la portion de code que lâ€™on veut tester.</p><p>Je vous propose maintenant la dÃ©finition que jâ€™ai en tÃªte quand je parle de TU: un test que lâ€™on peut exÃ©cuter en isolation et dont le comportement est rÃ©pÃ©table et constant.</p><p>Son rÃ©sultat ne dÃ©pend donc pas du rÃ©sultat dâ€™autres tests ni de lâ€™Ã©tat de dÃ©pendances externes au systÃ¨me (appel Ã  une web API, Ã  une base de donnÃ©es). Notez que je ne dÃ©finis pas la taille du pÃ©rimÃ¨tre testÃ©.</p><h2 id=des-tests-de-comportement>Des tests de comportement</h2><p>Aujourdâ€™hui, jâ€™adopte autant que possible une stratÃ©gie qui me permet de conserver ma capacitÃ© Ã  modifier le code.</p><p>Jâ€™Ã©cris mes tests de sorte quâ€™ils dÃ©pendent uniquement des contrats entre mon systÃ¨me et le monde extÃ©rieur (endpoint REST, base de donnÃ©es, bus de donnÃ©es, etc.). Tout le reste est une boÃ®te noire inaccessible.</p><p>Ainsi, un test se prÃ©sente typiquement de la faÃ§on suivanteÂ :</p><ol><li>Je dÃ©finis lâ€™Ã©tat du systÃ¨me (ex: donnÃ©es en BDD)</li><li>Je lance une action mÃ©tier via une API publique (ex: endpoint REST)</li><li>Je vÃ©rifie le nouvel Ã©tat de mon systÃ¨me (ex: donnÃ©es en BDD) et les Ã©ventuelles interactions avec le monde extÃ©rieur (ex: publication dâ€™un message sur un bus)</li></ol><p><img src=1.png alt="Schema explicatif"></p><p>Pour Ã©crire ces tests et les garder indÃ©pendants, jâ€™utilise des implÃ©mentations â€œin memoryâ€ de mes dÃ©pendances externes (typiquement la base de donnÃ©es). Je mâ€™assure Ã©galement que ces implÃ©mentations ont des comportements identiques Ã  celles que jâ€™utilise rÃ©ellement en production. Pour cela, jâ€™Ã©cris quelques tests dâ€™intÃ©grations paramÃ©trÃ©s qui testent uniquement les accÃ¨s au monde extÃ©rieur.</p><p><img src=2.png alt="Schema explicatif"></p><p>Cette approche peut paraÃ®tre extrÃªme, mais elle rÃ©pond au problÃ¨me que je souhaite adresser dans cet article.</p><p>Je dois tout de mÃªme lui reconnaÃ®tre certaines faiblessesÂ :</p><ul><li>Des boucles de feedbacks plus lentes.</li><li>Des erreurs parfois plus dures Ã  analyser.</li><li>Il reste un couplage Ã  certaines couches applicatives.</li></ul><h2 id=crÃ©er-des-abstractions>CrÃ©er des abstractions</h2><p>Il est tout de mÃªme nÃ©cessaire dâ€™aller un peu plus loin pour rÃ©duire lâ€™adhÃ©rence avec les tests. En effet, si nous avons rÃ©duit aux interfaces publiques la surface Ã  laquelle nous sommes couplÃ©s, celles-ci deviennent encore plus critiques en cas de modification.</p><p>Par expÃ©rience, un bon moyen de mesurer le couplage Ã  un contrat est de compter le nombre dâ€™endroits oÃ¹ celui-ci est instanciÃ©.</p><blockquote class=twitter-tweet><p lang=en dir=ltr>Every time I delay the creation of builders to populate data structures in my tests it comes back to bite me in the ass, forcing me to refactor many testes as my data structures evolve. My tests should not rely on their constructors and only care about the data they need.</p>&mdash; Sandro Mancuso (@sandromancuso) <a href="https://twitter.com/sandromancuso/status/1138172904347246592?ref_src=twsrc%5Etfw">June 10, 2019</a></blockquote><script async src=https://platform.twitter.com/widgets.js></script><p>Builders, gÃ©nÃ©rateurs ou encore donnÃ©es statiques, quel que soit la ou les technique(s) utilisÃ©e(s), lâ€™objectif reste toujours le mÃªmeÂ : isoler la crÃ©ation dâ€™une donnÃ©e, dâ€™un service, de lâ€™application, de sorte que si sa structure change, il ne faille appliquer ce changement quâ€™Ã  un seul endroit dans les tests.</p><p>Un autre bÃ©nÃ©fice de ces mÃ©thodes est quâ€™elles rendent les tests plus clairs, puisque vous nâ€™avez Ã  spÃ©cifier que les donnÃ©es qui font sens pour le scÃ©nario. Avec le temps, vous arriverez sans doute Ã  faire Ã©merger un DSL pour vos tests, lâ€™ajout de nouveaux use cases en sera facilitÃ© voir presque trivial.</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#00a8c8>var</span> <span style=color:#111>app</span> <span style=color:#111>=</span> <span style=color:#111>MonApp</span><span style=color:#111>.</span><span style=color:#111>Create</span><span style=color:#111>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Given</span>
</span></span><span style=display:flex><span><span style=color:#111>app</span><span style=color:#111>.</span><span style=color:#111>AddHistory</span><span style=color:#111>(</span><span style=color:#111>evt1</span><span style=color:#111>,</span> <span style=color:#111>evt2</span><span style=color:#111>,</span> <span style=color:#111>evt3</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span><span style=color:#111>app</span><span style=color:#111>.</span><span style=color:#111>DefineTime</span><span style=color:#111>(</span><span style=color:#111>givenTime</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// When</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>var</span> <span style=color:#111>controller</span> <span style=color:#111>=</span> <span style=color:#111>app</span><span style=color:#111>.</span><span style=color:#111>GetSomeController</span><span style=color:#111>();</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>var</span> <span style=color:#111>result</span> <span style=color:#111>=</span> <span style=color:#111>controller</span><span style=color:#111>.</span><span style=color:#111>ExecuteCommand</span><span style=color:#111>(</span><span style=color:#111>arg1</span><span style=color:#111>,</span> <span style=color:#111>arg2</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Then</span>
</span></span><span style=display:flex><span><span style=color:#111>VerifyAssertion</span><span style=color:#111>(</span><span style=color:#111>result</span><span style=color:#111>);</span>
</span></span><span style=display:flex><span><span style=color:#111>app</span><span style=color:#111>.</span><span style=color:#111>VerifyOnHistory</span><span style=color:#111>(</span><span style=color:#111>myAssertion</span><span style=color:#111>);</span>
</span></span></code></pre></div><h2 id=pour-conclure>Pour conclure</h2><p>Il mâ€™est arrivÃ© plusieurs fois de rencontrer des gens qui ont tentÃ© de mettre en place des tests unitaires ou du TDD sur leur projet, et qui y ont finalement renoncÃ© aprÃ¨s quelque temps parce que â€œÃ§a ne marche pasâ€. Je pense que le problÃ¨me que jâ€™ai Ã©voquÃ© au cours de cet article est la principale raison de ces abandons.</p><p>Attention Ã©galement aux dogmesÂ ! Si je me montre critique envers les tests unitaires â€œpetite mailleâ€, ceux-ci peuvent se rÃ©vÃ©ler utiles et parfois plus simples quâ€™un test â€œboÃ®te noireâ€. De la mÃªme maniÃ¨re, il est parfois plus simple dâ€™utiliser un mock plutÃ´t que de dÃ©finir lâ€™Ã©tat du systÃ¨me dans sa globalitÃ©. Il est ici question de compromis, de choix qui doivent Ãªtre faits en connaissance de cause.</p><p>Si cet article vous a plu, je vous recommande de regarder la confÃ©rence <a href="https://www.youtube.com/watch?v=EZ05e7EMOLM" target=_blank>DevTernity 2017: Ian Cooper â€“ TDD, Where Did It All Go Wrong</a>.</p><p>Edit 1Â : Je vous partage Ã©galement cet article que lâ€™on mâ€™a montrÃ© en rÃ©action Ã  ce post et qui explique sans doute mieux que moi le point que je souhaitais traiter ici.</p><p>Edit 2Â : Deux autres remarques mâ€™ont Ã©tÃ© faitesÂ :</p><ul><li>Certains tests sont dÃ©jÃ  naturellement isolÃ©s (domaine, hexagone) et ne dÃ©pendent pas de dÃ©tails dâ€™implÃ©mentations. Ceux-ci sont aussi viables que la stratÃ©gie que je propose dans cet article.</li><li>Si les tests Â« petite maille Â» ne sont pas idÃ©als sur le long terme, ils peuvent Ãªtre trÃ¨s utiles comme Â« Ã©chaffaudage Â» pour implÃ©menter progressivement un scÃ©nario plus vaste. Ã€ condition de les supprimer une fois les conditions dâ€™un test Â« grosse maille Â» remplies.</li></ul><hr><h2 id=commentaires>Commentaires</h2><p>Envie de commenter ? Sâ€™il vous plaÃ®t, ajoutez votre commentaire en m&rsquo;<a href="https://github.com/RomainTrm/Blog?tab=readme-ov-file#how-to-comment" target=_blank>envoyant une pull request</a>.</p></article><div class=tags><span title=Tags>ğŸ·</span><div class="horizontal-links links"><a href=/tags/post/>Post</a><a href=/tags/fr/>Fr</a></div></div></article></main><footer><div class=content-container><div class=content><div class=about><h2>Romain Berthon</h2>Software developer, *DD and F# enthusiast<p class=horizontal-links><a href=https://github.com/RomainTrm target=_blank>Github</a><a href=https://bsky.app/profile/berthon.dev target=_blank>Bsky</a><a href=https://fr.linkedin.com/in/romain-berthon-254977101 target=_blank>LinkedIn</a></p></div></div></div></footer></body></html>