<!doctype html><html><meta charset=utf-8><meta http-equiv=Content-Security-Policy content="default-src 'none'; script-src 'none'; style-src 'self' 'sha256-hevimW2qBMcsaZR62OkETyNJKvnMSjRYOz6kIyvEFtg='; img-src 'self'; connect-src 'self'; base-uri 'self'; manifest-src 'self'; media-src 'self'"><meta http-equiv=Strict-Transport-Security content="max-age=63072000; includeSubDomains; preload"><meta http-equiv=X-Content-Type-Options content="nosniff"><meta http-equiv=Referrer-Policy content="strict-origin-when-cross-origin"><meta name=viewport content="width=device-width,initial-scale=1"><title>Ã€ la dÃ©couverte du Property Based Testing Â· Romain Berthon</title>
<link rel=stylesheet href=/css/rocinante.css><link rel="shortcut icon" href=https://berthon.dev//favicon.ico><body><header><nav><a class=home href=https://berthon.dev/>â€¹ Home</a><div></div><div><a href=https://berthon.dev//tags/post>Posts</a>
<a href=https://berthon.dev//tags/talk>Talks</a>
<a href=https://berthon.dev//about>About</a></div></nav></header><main><div class=post><div class=title-group><div class=title><h1>Ã€ la dÃ©couverte du Property Based Testing</h1></div><div class=date><h5>Jan 08, 2019</h5></div></div><article class=content><p>Je suis un dÃ©veloppeur convaincu par les bÃ©nÃ©fices du TDD, je lâ€™applique au quotidien sur les projets que me confient mes clients. Cela me permet de rapidement valider que mon code a bien le comportement attendu, de le â€œdocumenterâ€ et dÃ©crivant un cas dâ€™usage et de mâ€™assurer par la suite que je nâ€™introduis aucune rÃ©gression si je modifie le code testÃ©.</p><p>Je fais tout ceci en sachant que je choisis des cas de test qui me semblent reprÃ©sentatifs de lâ€™usage de la fonction, on parle parfois dâ€™Example Based Tests. Si cette mÃ©thode est souvent suffisante, il mâ€™arrive parfois de me poser les questions suivantesÂ : Puis-je Ãªtre sÃ»r que ma fonction est correctement dÃ©veloppÃ©e si je ne suis pas capable dâ€™identifier un cas qui est reprÃ©sentatifÂ ? Ai-je bien identifiÃ© tous les cas limitesÂ ?</p><p>Câ€™est lÃ  quâ€™il devient intÃ©ressant de se pencher sur le property based testing.</p><h2 id=cest-quoi-le-property-based-testing-pbtnbsp>Câ€™est quoi le Property Based Testing (PBT)Â ?</h2><p>Lâ€™idÃ©e est simpleÂ : identifier et tester des invariants. Comprenez quelque chose qui sera toujours vrai, quelles que soient les donnÃ©es que vous fournissez Ã  votre algorithme.</p><p>Pour cela, il faut utiliser un framework qui va gÃ©nÃ©rer des donnÃ©es alÃ©atoires et vÃ©rifier si lâ€™invariant reste vrai. Ã€ chaque exÃ©cution de votre suite de tests, celui-ci va tester diffÃ©rentes combinaisons (gÃ©nÃ©ralement une centaine). Il est important de noter quâ€™un test de PBT en succÃ¨s ne signifie pas que lâ€™implÃ©mentation est correcte, il veut juste dire que le framework nâ€™a pas su mettre en dÃ©faut lâ€™implÃ©mentation. Il est tout Ã  fait possible que celui-ci trouve un cas limite aprÃ¨s plusieurs heures, jours, semaines, moisâ€¦</p><h2 id=ok-et-si-un-test-Ã©chouenbsp>Ok, et si un test Ã©choueÂ ?</h2><p>Si le framework arrive finalement Ã  trouver un cas limite, il existe trois possibilitÃ©sÂ :</p><ul><li>le code de production nâ€™est pas correct</li><li>la faÃ§on dont lâ€™invariant est testÃ© nâ€™est pas correcte</li><li>la comprÃ©hension et dÃ©finition de lâ€™invariant ne sont pas correctes</li></ul><p>Il est important dâ€™avoir cette rÃ©flexion dÃ¨s quâ€™un cas est identifiÃ©. Quoi quâ€™il en soit, le framework est capable de vous donner les donnÃ©es utilisÃ©es pour mettre Ã  mal votre code, vous pouvez donc facilement Ã©crire un TU classique pour reproduire le cas.</p><p>Un bon framework de PBT est capable de faire du shrinking. Une fois le cas limite identifiÃ©, celui-ci va travailler sur les donnÃ©es utilisÃ©es pour essayer de les simplifier au maximum tout en reproduisant lâ€™erreur. Ceci nous facilite lâ€™effort dâ€™analyseÂ : imaginez une fonction qui prend une liste en argument, est-ce ma liste de 250 Ã©lÃ©ments ou juste un Ã©lÃ©ment qui plante mon codeÂ ? Sâ€™il sâ€™agit dâ€™un Ã©lÃ©ment, le shrinking peut lâ€™isoler.</p><h2 id=cest-quoi-un-invariantnbsp-un-exemplenbsp>Câ€™est quoi un invariantÂ ? Un exempleÂ ?</h2><p>Câ€™est Ã  la fois tout lâ€™intÃ©rÃªt de cette mÃ©thode de test, mais aussi toute sa difficultÃ©. Il faut Ãªtre capable de raisonner sur le mÃ©tier de son application pour pouvoir en faire Ã©merger des rÃ¨gles.</p><p>Un des premiers exemples que lâ€™on peut rencontrer est celui de lâ€™addition. Celle-ci a trois propriÃ©tÃ©sÂ :</p><ul><li>Lâ€™identitÃ©Â : x + 0 = x avec 0 comme Ã©lÃ©ment neutre</li><li>Lâ€™associativitÃ©Â : (a + b) + c = a + (b + c)</li><li>La commutativitÃ©Â : a + b = b + a</li></ul><p>Vous retrouvez Ã©galement ces propriÃ©tÃ©s avec la multiplication, seul lâ€™Ã©lÃ©ment neutre change. Ces exemples sont trÃ¨s mathÃ©matiques (et peu intÃ©ressants), mais ce nâ€™est pas le cas de toutes les propriÃ©tÃ©s, celles-ci peuvent prendre diverses formes.</p><p>Petite appartÃ©e, les exemples qui suivent sont Ã©crits en F# avec FsCheck. Jâ€™ai volontairement choisi un â€œmauvaisâ€ exemple mÃ©tier puisquâ€™il est envisageable de tester tous les cas de maniÃ¨re unitaires, mais il me paraÃ®t trÃ¨s adaptÃ© pour illustrer ce quâ€™est un invariant.</p><p>Pour cet exemple, jâ€™ai dÃ©cidÃ© dâ€™Ã©crire un petit programme qui doit me dire quelle est la main gagnante entre deux mains de deux cartes. Il sâ€™agit dâ€™une version simplifiÃ©e du Poker, si vous ne les connaissez pas, voici les rÃ¨glesÂ :</p><ul><li>si les deux mains sont Ã©quivalentes, alors il y a Ã©galitÃ©</li><li>une paire gagne sur une main mixte (main avec deux cartes diffÃ©rentes)</li><li>sâ€™il y a deux paires, la paire avec la meilleure carte gagne</li><li>sâ€™il y a deux mains mixtesÂ :<ul><li>on compare la carte la plus forte de chaque main</li><li>si les cartes les plus fortes sont identiques, on compare les cartes les moins fortes</li></ul></li><li>lâ€™As est la meilleure carte et le deux la moins bonne</li></ul><p>Je vous laisse quelques secondes pour trouver des invariantsâ€¦</p><p>Vous avez trouvÃ©Â ? Il sâ€™agit tout simplement de la liste de rÃ¨gles que je viens dâ€™Ã©noncerÂ : celles-ci sont toujours vraies.</p><p>Ok, prenons la premiÃ¨re rÃ¨gleÂ : â€œsi deux mains sont Ã©quivalentes, alors il y a Ã©galitÃ©â€. Pour cela, je laisse le framework me gÃ©nÃ©rer deux cartes alÃ©atoires (seule la valeur de la carte importe ici) qui constituent les deux mainsÂ :</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Fsharp data-lang=Fsharp><span style=display:flex><span><span style=color:#f92672>[&lt;</span><span style=color:#111>Property</span><span style=color:#f92672>&gt;]</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>let</span> <span style=color:#111>``Return draw when hands are equals``</span> <span style=color:#111>card1</span> <span style=color:#111>card2</span> <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#111>getBestHand</span> <span style=color:#f92672>(</span><span style=color:#111>card1</span><span style=color:#f92672>,</span> <span style=color:#111>card2</span><span style=color:#f92672>)</span> <span style=color:#f92672>(</span><span style=color:#111>card2</span><span style=color:#f92672>,</span> <span style=color:#111>card1</span><span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#111>Draw</span>
</span></span></code></pre></div><p>On peut aussi tester quâ€™une paire est toujours meilleure quâ€™une main mixte. Dans ce cas, on doit sâ€™assurer que les cartes gÃ©nÃ©rÃ©es par le framework sont diffÃ©rentes. Pour cela, il est possible de poser des conditions qui, si elles sont respectÃ©es, permettent lâ€™exÃ©cution du cas de testÂ :</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Fsharp data-lang=Fsharp><span style=display:flex><span><span style=color:#f92672>[&lt;</span><span style=color:#111>Property</span><span style=color:#f92672>&gt;]</span>
</span></span><span style=display:flex><span><span style=color:#00a8c8>let</span> <span style=color:#111>``Pair is always better than random hand``</span> <span style=color:#111>card1</span> <span style=color:#111>card2</span> <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#111>card1</span> <span style=color:#f92672>&lt;&gt;</span> <span style=color:#111>card2</span> <span style=color:#f92672>==&gt;</span> <span style=color:#00a8c8>lazy</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>(</span><span style=color:#111>getBestHand</span> <span style=color:#f92672>(</span><span style=color:#111>card1</span><span style=color:#f92672>,</span> <span style=color:#111>card1</span><span style=color:#f92672>)</span> <span style=color:#f92672>(</span><span style=color:#111>card1</span><span style=color:#f92672>,</span> <span style=color:#111>card2</span><span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#111>Winner</span> <span style=color:#f92672>(</span><span style=color:#111>card1</span><span style=color:#f92672>,</span> <span style=color:#111>card1</span><span style=color:#f92672>))</span> <span style=color:#f92672>|@</span> <span style=color:#d88200>&#34;Pair as left hand&#34;</span> <span style=color:#f92672>.&amp;.</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>(</span><span style=color:#111>getBestHand</span> <span style=color:#f92672>(</span><span style=color:#111>card1</span><span style=color:#f92672>,</span> <span style=color:#111>card2</span><span style=color:#f92672>)</span> <span style=color:#f92672>(</span><span style=color:#111>card2</span><span style=color:#f92672>,</span> <span style=color:#111>card2</span><span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#111>Winner</span> <span style=color:#f92672>(</span><span style=color:#111>card2</span><span style=color:#f92672>,</span> <span style=color:#111>card2</span><span style=color:#f92672>))</span> <span style=color:#f92672>|@</span> <span style=color:#d88200>&#34;Pair as right hand&#34;</span>
</span></span></code></pre></div><p>Je ne vais pas dÃ©tailler lâ€™ensemble des cas de test sur cet article, vous pouvez tenter de le refaire de votre cÃ´tÃ©. Vous pourrez trouver une solution possible sur mon <a href=https://github.com/RomainTrm/KataPokerHands/blob/master/KataPokerHands_FSharp/PokerHand_PropertyBase.fs target=_blank>github</a>.</p><p>CERTAINES IMPRÃ‰CISIONS
Contrairement Ã  un TU, il nâ€™est pas toujours possible de spÃ©cifier le rÃ©sultat exact que lâ€™on attend Ã  lâ€™issue dâ€™un test de PBT. Pour rÃ©pondre Ã  ceci, jâ€™aime beaucoup la dÃ©finition proposÃ©e par <a href=https://twitter.com/jessitron target=_blank>Jessica Kerr</a>.</p><p>Un test de PBT dÃ©fini un cadre mÃ©tier dont on ne doit pas sortirÂ :</p><p><img src=1.png alt="Un nuage de points avec certains dans le cadre, d&rsquo;autres Ã  l&rsquo;extÃ©rieur"></p><p>Lâ€™idÃ©e est dâ€™Ãªtre moins spÃ©cifique sur le rÃ©sultat, lâ€™important est de sâ€™assurer que les impÃ©ratifs mÃ©tiers sont validÃ©s. Cela prÃ©sente lâ€™avantage de laisser une plus grande libertÃ© dans lâ€™implÃ©mentation puisque son couplage avec le test est moins important.</p><p>Si lâ€™on souhaite tout de mÃªme tester un rÃ©sultat de maniÃ¨re exacte, alors il faudra revenir Ã  un test unitaire avec un rÃ©sultat hard-codÃ©.</p><h2 id=pour-conclure>Pour conclure</h2><p>On peut trouver certains inconvÃ©nients au PBT, comme des temps dâ€™exÃ©cution un peu plus longs que des tests unitaires classiques, ou encore une plus grande difficultÃ© Ã  Ã©crire ces tests.</p><p>Mais vous lâ€™aurez compris, le PBT amÃ©liore notre comprÃ©hension de lâ€™application puisquâ€™il pousse Ã  raisonner Ã  des niveaux dâ€™abstraction plus Ã©levÃ©s que ce que nous incite Ã  faire des tests unitaires classiquesÂ : â€œune paire est meilleure quâ€™une main mixteâ€ est Ã  un niveau dâ€™abstraction supÃ©rieur Ã  â€œune paire de 5 est meilleure que la main avec le 8 et le roiâ€.</p><p>Enfin, parce que le code est validÃ© par un grand nombre de cas diffÃ©rents, le PBT amÃ©liore Ã©galement la qualitÃ© de notre code ainsi que la confiance que nous avons dans celui-ci.</p><p>Si aprÃ¨s la lecture de cet article le PBT vous intÃ©resse, vous pouvez Ã©galement regarder ce <a href=https://youtu.be/shngiiBfD80 target=_blank>talk</a> de <a href=https://twitter.com/jessitron target=_blank>Jessica Kerr</a> ou encore <a href=https://youtu.be/5pwv3cuo3Qk target=_blank>celui</a> de <a href=https://twitter.com/malk_zameth target=_blank>Romeu Mourra</a> qui sont pour moi des rÃ©fÃ©rences sur ce sujet.</p><hr><h2 id=commentaires>Commentaires</h2><p>Envie de commenter ? Sâ€™il vous plaÃ®t, ajoutez votre commentaire en m&rsquo;<a href="https://github.com/RomainTrm/Blog?tab=readme-ov-file#how-to-comment" target=_blank>envoyant une pull request</a>.</p></article><div class=tags><span title=Tags>ğŸ·</span><div class="horizontal-links links"><a href=/tags/post/>Post</a><a href=/tags/fr/>Fr</a></div></div></article></main><footer><div class=content-container><div class=content><div class=about><h2>Romain Berthon</h2>Software developer, *DD and F# enthusiast<p class=horizontal-links><a href=https://github.com/RomainTrm target=_blank>Github</a><a href=https://bsky.app/profile/berthon.dev target=_blank>Bsky</a><a href=https://fr.linkedin.com/in/romain-berthon-254977101 target=_blank>LinkedIn</a></p></div></div></div></footer></body></html>