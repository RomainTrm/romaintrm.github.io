<!doctype html><html><meta charset=utf-8><meta http-equiv=Content-Security-Policy content="default-src 'none'; script-src 'none'; style-src 'self' 'unsafe-inline'; img-src 'self'; connect-src 'self'; base-uri 'self'; manifest-src 'self'; media-src 'self'"><meta http-equiv=Strict-Transport-Security content="max-age=63072000; includeSubDomains; preload"><meta http-equiv=X-Content-Type-Options content="nosniff"><meta http-equiv=Referrer-Policy content="strict-origin-when-cross-origin"><meta name=viewport content="width=device-width,initial-scale=1"><title>Uniformiser le code, bonne idÃ©e ? Â· Romain Berthon</title>
<link rel=stylesheet href=/css/rocinante.css><link rel="shortcut icon" href=https://berthon.dev//favicon.ico><body><header><nav><a class=home href=https://berthon.dev/>â€¹ Home</a><div></div><div><a href=https://berthon.dev//tags/post>Posts</a>
<a href=https://berthon.dev//tags/talk>Talks</a>
<a href=https://berthon.dev//about>About</a></div></nav></header><main><div class=post><div class=title-group><div class=title><h1>Uniformiser le code, bonne idÃ©e ?</h1></div><div class=date><h5>Sep 01, 2021</h5></div></div><article class=content><p>Au cours de ma carriÃ¨re, jâ€™ai Ã©tÃ© confrontÃ© Ã  plusieurs reprises Ã  des clients et/ou des acteurs internes qui souhaitent assurer un haut niveau dâ€™uniformisation sur le code des applications. Cela se traduit par des conventions de style, de nommage, et parfois mÃªme des choix plus impactant comme des frameworks ou des architectures spÃ©cifiques. Dans les cas extrÃªmes, les propos de ces personnes laissaient entendre le refus dâ€™un quelconque Ã©cart avec ces rÃ¨gles.</p><p>De mon expÃ©rience, la motivation derriÃ¨re cette dÃ©marche est toujours la mÃªmeÂ : permettre Ã  un dÃ©veloppeur de facilement passer dâ€™une application Ã  une autre. En effet, les dÃ©veloppeurs sont encore aujourdâ€™hui des ressources rares et chÃ¨res au regard du marchÃ©, et la plupart des entreprises nâ€™ont pas les moyens dâ€™attirer et dâ€™en employer un grand nombre. Il sâ€™agit donc ici pour lâ€™entreprise de maximiser lâ€™usage des ressources limitÃ©es quâ€™elle a Ã  sa disposition. Cependant, cela implique dâ€™appliquer ces conventions Ã  lâ€™Ã©chelle dâ€™un sous-ensemble dâ€™applications, voire mÃªme Ã  lâ€™ensemble des applications dâ€™une entreprise.</p><p>Si ces motivations me paraissent tout Ã  fait lÃ©gitimes et raisonnables, je ne suis pas totalement en accord avec la solution envisagÃ©e, tout du moins sous ses formes extrÃªmes. Je vais tenter ici dâ€™apporter ma rÃ©flexion sur le sujet.</p><h2 id=disclaimer>Disclaimer</h2><p>Dans ce billet je vais raisonner Ã  une Ã©chelle macroÂ : un ensemble dâ€™applications ou une seule application regroupant diffÃ©rents contextes mÃ©tiers. Au sein dâ€™un pÃ©rimÃ¨tre restreint (un contexte mÃ©tier), il me semble en effet important de prÃ©server un minimum de cohÃ©rence dans le code. Ã€ noter Ã©galement que je ne remets pas en cause ici lâ€™intÃ©rÃªt dâ€™uniformiser la partie infrastructure et configuration de vos systÃ¨mes. Si par exemple vous travaillez avec Microsoft Azure ou Amazon AWS, vous voudrez sans doute maintenir une faÃ§on cohÃ©rente de vous interfacer avec ces plateformes.</p><h2 id=un-mÃªme-si-mais-diffÃ©rents-contextes>Un mÃªme si, mais diffÃ©rents contextes</h2><p>Comme je lâ€™ai dÃ©jÃ  Ã©voquÃ©, le vrai bÃ©nÃ©fice dâ€™uniformiser le code est de permettre au dÃ©veloppeur de rester en terrain connu. Il peut rapidement trouver ses marques comme la structure technique de lâ€™application est dÃ©jÃ  connue. Le plus gros de lâ€™effort se focalise sur la comprÃ©hension de lâ€™application, de son mÃ©tier.</p><p>Hors, si lâ€™on sâ€™intÃ©resse aux diffÃ©rents mÃ©tiers dâ€™une entreprise / dâ€™une application, on se rend compte quâ€™ils ne sont pas homogÃ¨nes en termes de valeur produite, de complexitÃ©, dâ€™usage, de volumÃ©trie des donnÃ©es, et mÃªme pourquoi pas de charge de travail. Certains mÃ©tiers vont Ã©galement Ãªtre dÃ©pendants dâ€™autres mÃ©tiers pour produire de la valeur. Un outil comme les <a href=https://learnwardleymapping.com/ target=_blank>Wardley Map</a> permet aujourdâ€™hui de bien mettre en lumiÃ¨re ces dÃ©pendances, mais aussi les diffÃ©rences de maturitÃ© et de spÃ©cificitÃ© business des composants dâ€™un SI.</p><p>La sphÃ¨re DDD nous propose une sÃ©grÃ©gation par Bounded Context pour structurer une application. En fonction du rÃ´le (Core, Support, Generic) du domain associÃ©, les solutions techniques proposÃ©es ne sont pas les mÃªmes (cf: <a href=https://www.goodreads.com/book/show/28602719-domain-driven-design-distilled target=_blank>Domain-Driven Design Distilled</a>, Types of subdomains, p.46)Â :</p><ul><li>CoreÂ : mÃ©tier trÃ¨s spÃ©cifique Ã  lâ€™entreprise, code avec des efforts de modÃ©lisation et dÃ©veloppement importants.</li><li>SupportÂ : mÃ©tier plus simple et supportant le Core, code avec des efforts moindres.</li><li>GenericÂ : intÃ©gration et usage de systÃ¨mes tiers ou outsourcÃ©s.</li></ul><p>De mon expÃ©rience, et de faÃ§on grossiÃ¨re, une application business sâ€™articule souvent de cette maniÃ¨reÂ : un mÃ©tier complexe, dÃ©pendant de mÃ©tiers pÃ©riphÃ©riques (avec souvent des mÃ©tiers de â€œparamÃ©trageâ€), et qui vient parfois interagir avec des systÃ¨mes tiers, par exemple un CRM.</p><p>Lâ€™usage de conventions de code uniformisÃ©es peut faire sens dans le cas des supporting domains. Une simple architecture de type CRUD peut par exemple se rÃ©vÃ©ler suffisante pour rÃ©pondre Ã  ces besoins. Cependant cela me semble inadaptÃ© aux core domain (par les contraintes mÃ©tiers fortes) ainsi quâ€™aux generic domain (contraint par les systÃ¨mes tiers). Porter lâ€™uniformisation du code Ã  ces contextes augmente la complexitÃ© et fait tendre vers des solutions sous optimales.</p><h2 id=nos-limites-cognitives>Nos limites cognitives</h2><p>Nous sommes tous contraints par les limites de nos capacitÃ©s cognitives, ce qui correspond Ã  lâ€™ensemble des informations que lâ€™on est capable de traiter Ã  un instant donnÃ©. Il faut garder en tÃªte que toutes les applications ne reprÃ©sentent pas la mÃªme charge cognitive pour un dÃ©veloppeur, et que plus il a dâ€™applications Ã  gÃ©rer, plus sa charge cognitive est importante. Uniformiser le code permet dans une certaine mesure de rÃ©duire cette charge et dâ€™accÃ©lÃ©rer la transition vers une autre application.</p><p>Mais mÃªme avec cela, un trop grand nombre dâ€™applications reste problÃ©matiqueÂ :</p><ul><li>Trop dâ€™informations Ã  garder en tÃªte pour Ãªtre rÃ©ellement efficace.</li><li>Un temps et de lâ€™Ã©nergie consÃ©quents perdus lors de nombreux â€œcontext switchingâ€.</li></ul><p>Pour lutter efficacement contre cette limite, on peut envisager dâ€™autres stratÃ©gies qui visent Ã  limiter le nombre dâ€™applications dont un dÃ©veloppeur peut Ãªtre responsable.</p><p>Si lâ€™on en revient aux Wardley Maps, on peut dÃ©jÃ  simplement se demanderÂ : â€œÃ€ quoi sert cette applicationÂ ? Est-elle vraiment essentielle pour mon businessÂ ?â€ Posez-vous sÃ©rieusement ces questions sans les Ã©vacuer dâ€™un revers de manche. Simplifiez autant que possible, car nous avons tendance Ã  surcomplexifier les systÃ¨mes que nous produisons, et aussi Ã  apporter des solutions Ã  des problÃ¨mes qui ne devraient pas exister.</p><blockquote class=twitter-tweet><p lang=en dir=ltr>You may not be interested by rocketry, but Elon gives us here a lot of heuristics for designing efficient systems. It matches perfectly well with software development.<a href=https://t.co/wjmePPe6VA>https://t.co/wjmePPe6VA</a></p>&mdash; Romain Berthon (@RomainTrm) <a href="https://twitter.com/RomainTrm/status/1424013279479877635?ref_src=twsrc%5Etfw">August 7, 2021</a></blockquote><script async src=https://platform.twitter.com/widgets.js></script><p>Une autre stratÃ©gie (peut-Ãªtre moins recommandable) est dâ€™accepter que certaines applications ne soient plus maintenues par quiconque pendant un temps. Bien entendu, vous ne pouvez pas faire Ã§a avec toutes vos applications, ici ce sont les contextes generic et supporting qui peuvent Ãªtre concernÃ©s. Il est tout de mÃªme important dâ€™identifier la frÃ©quence des changements ainsi que les futures Ã©volutions nÃ©cessaires avant de laisser vivre une application.</p><p>Parfois, le besoin dâ€™uniformiser le code est exprimÃ© par les dÃ©veloppeurs eux-mÃªmes. De mon expÃ©rience, cette demande vient toujours de profils transverses Ã  qui on demande dâ€™intervenir sur plusieurs projets en mÃªme temps. Cela peut parfois mettre en lumiÃ¨re un problÃ¨me dâ€™organisation (pourquoi a-t-il besoin de travailler sur tous ces projetsÂ ?). Mais il reste important dâ€™Ã©couter ce type de retour et dâ€™Ã©valuer si une action dâ€™uniformisation est nÃ©cessaire.</p><h2 id=innovations-et-gestion-des-risques>Innovations et gestion des risques</h2><p>Lorsque lâ€™on conÃ§oit un systÃ¨me, il est rare de trouver immÃ©diatement la bonne solution, le bon design. Câ€™est particuliÃ¨rement vrai dans le logiciel oÃ¹ le code change, les fonctionnalitÃ©s Ã©voluent. Il est donc trÃ¨s difficile dâ€™anticiper les besoins futurs, et tenter dâ€™anticiper nâ€™est pas toujours souhaitable, car celÃ  nous mÃ¨ne rÃ©guliÃ¨rement Ã  des optimisations prÃ©maturÃ©es et de lâ€™over-engineering.</p><p>Pour cela, il est important de rester ouvert aux changements et aux propositions dâ€™Ã©volution. Lâ€™amÃ©lioration des pratiques passe alors nÃ©cessairement par une phase dâ€™expÃ©rimentation et dâ€™exploration.</p><p>Quand une nouvelle contrainte apparaÃ®t, il faut donc comprendre ses impacts sur la solution actuelle et identifier de potentielles Ã©volutions Ã  apporter pour mieux y rÃ©pondre. Cependant, si lâ€™on souhaite conserver un code toujours uniformisÃ©, deux scÃ©narios sâ€™offrent Ã  nousÂ :</p><ul><li>La quantitÃ© de code Ã  modifier est trop importante, et le changement nâ€™a pas lieu, on continue donc Ã  travailler sur solution sous-optimale et lâ€™on accumule de la dette.</li><li>On se lance dans une Ã©volution â€œbig-bangâ€, sans savoir si la solution envisagÃ©e est la bonne, ni mÃªme si elle va aboutir. LÃ  aussi, la mÃ©thode est sous-optimale puisquâ€™il faut investir beaucoup de temps et dâ€™Ã©nergie avant dâ€™espÃ©rer un quelconque rÃ©sultat. Sans compter lâ€™introduction de potentiels bugs dans des fonctionnalitÃ©s qui ne nÃ©cessitent aucune Ã©volution et qui fonctionnent parfaitement, ce qui est trÃ¨s frustrant pour ses utilisateurs.</li></ul><p>Si les standards peuvent Ã©voluer, il est donc plus pertinent de dâ€™abord les tester sur un pÃ©rimÃ¨tre limitÃ©, et ainsi rapidement obtenir des feedbacks. Si les changements ne sont pas pertinents, alors le temps et lâ€™Ã©nergie engagÃ©s auront Ã©tÃ© limitÃ©s et il est simple de faire machine arriÃ¨re. Si ceux-ci se montrent pertinents, on peut alors les gÃ©nÃ©raliser de faÃ§on opportuniste, progressivement au fils des dÃ©veloppements afin de mieux gÃ©rer les risques liÃ©s Ã  ces Ã©volutions.</p><h2 id=motivation-des-Ã©quipes>Motivation des Ã©quipes</h2><p>Outre le fait de ne pas rester coincÃ© dans une solution inadaptÃ©e, les livres <a href=https://itrevolution.com/product/accelerate/ target=_blank>Accelerate</a> (Allow teams to choose their own tools, p.66) et <a href=https://teamtopologies.com/book target=_blank>Team Topologies</a> (Monolithic thinking (Standardization), p.114) soulignent Ã©galement lâ€™aspect humain; ces phases dâ€™expÃ©rimentation et dâ€™exploration tendent Ã  augmenter lâ€™engagement et la motivation des dÃ©veloppeurs.</p><p>Jâ€™y suis pour ma part trÃ¨s sensible, et un entretien avec un potentiel client oÃ¹ celui-ci insiste trop sur lâ€™importance de coder selon ses standards est pour moi un mauvais signal. Ceci parce que le message que jâ€™en retiens estÂ : â€œTu devras subir des choix passÃ©s, que tu nâ€™as pas pris, et ce sans aucune possibilitÃ© de tâ€™en extraire, mÃªme sâ€™ils sâ€™avÃ¨rent mauvais aujourdâ€™hui. Â» Bref, pas trÃ¨s motivant. Jâ€™ai dÃ©jÃ  refusÃ© des missions pour cette raison.</p><h2 id=pour-conclure>Pour conclure</h2><p>Vous lâ€™aurez compris, je ne suis pas un grand dÃ©fenseur de lâ€™uniformisation du code Ã  lâ€™Ã©chelle dâ€™une entreprise. Parce que les avantages que lâ€™on peut en tirer me semblent finalement assez limitÃ©s (limites cognitives, innovations, motivations), et aussi parce que cette approche a vocation Ã  soigner les symptÃ´mes plus que les causes du problÃ¨me (organisation, complexitÃ© du systÃ¨me). Comme je lâ€™ai dÃ©jÃ  Ã©voquÃ©, cette pratique peut faire sens pour des mÃ©tiers Â« satellites Â» Ã  faible complexitÃ© et sur lesquels les efforts de dÃ©veloppements seront limitÃ©s. Sur ce sujet (comme pour beaucoup dâ€™autres), tout est question dâ€™Ã©quilibre, il faut constamment veiller Ã  ne pas sâ€™enfermer dans un extrÃªme.</p><hr><h2 id=commentaires>Commentaires</h2><p>Envie de commenter ? Sâ€™il vous plaÃ®t, ajoutez votre commentaire en m&rsquo;<a href="https://github.com/RomainTrm/Blog?tab=readme-ov-file#how-to-comment" target=_blank>envoyant une pull request</a>.</p></article><div class=tags><span title=Tags>ğŸ·</span><div class="horizontal-links links"><a href=/tags/post/>Post</a><a href=/tags/fr/>Fr</a></div></div></article></main><footer><div class=content-container><div class=content><div class=about><h2>Romain Berthon</h2>Software developer, *DD and F# enthusiast<p class=horizontal-links><a href=https://github.com/RomainTrm target=_blank>Github</a><a href=https://bsky.app/profile/berthon.dev target=_blank>Bsky</a><a href=https://fr.linkedin.com/in/romain-berthon-254977101 target=_blank>LinkedIn</a></p></div></div></div></footer></body></html>