<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Romain Berthon</title><link>https://berthon.dev/posts/</link><description>Recent content in Posts on Romain Berthon</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Wed, 28 Jan 2026 09:00:00 +0100</lastBuildDate><atom:link href="https://berthon.dev/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Events as a means of communication</title><link>https://berthon.dev/posts/events-as-a-means-of-communication/</link><pubDate>Wed, 28 Jan 2026 09:00:00 +0100</pubDate><guid>https://berthon.dev/posts/events-as-a-means-of-communication/</guid><description>I&amp;rsquo;ve recently finished reading Real-World Event Sourcing. It was a fun reading, but I found the book unclear on a very specific point and I want to express my thoughts on it in this blog post. I may have misinterpreted the author&amp;rsquo;s explanations but this doesn&amp;rsquo;t invalidate the following reflection.
How to define an event stream? As the book is about Event Sourcing and CQRS (Command Query Responsibility Segregation), events are naturally the central building block: they&amp;rsquo;re used to store states and trigger effects in the system.</description></item><item><title>Reaching a limit of Reactive Programming</title><link>https://berthon.dev/posts/reaching-a-limit-of-reactive-programming/</link><pubDate>Wed, 12 Nov 2025 09:00:00 +0100</pubDate><guid>https://berthon.dev/posts/reaching-a-limit-of-reactive-programming/</guid><description>In my career, I had (and still have) many opportunities to develop UIs on desktop and web applications using various technologies. With these experiences I&amp;rsquo;ve been using two main patterns: MVVM (Model-View-ViewModel) and a Reactive approach.
In this post, I want to talk about the Reactive approach and especially about two features where it has become a burden to me.
What I mean by Reactive I am not talking about a specific framework here.</description></item><item><title>Learning Elixir</title><link>https://berthon.dev/posts/learning-elixir/</link><pubDate>Wed, 20 Aug 2025 09:00:00 +0200</pubDate><guid>https://berthon.dev/posts/learning-elixir/</guid><description>In a previous post, I&amp;rsquo;ve mentioned I&amp;rsquo;ve read the book Programming Elixir 1.6.
As I was planning to read Real-World Event Sourcing, I chose to conduct a second reading because my limited knowledge and skills with Elixir were eroded over time. I took time to take many notes which are available on a dedicated repository.
In this post, I want to present to you the Elixir language, the Erlang VM and give you a taste of why you should learn it even if you will not use it in production.</description></item><item><title>From a state-based to an event-sourced codebase</title><link>https://berthon.dev/posts/from-a-state-based-to-an-event-sourced-codebase/</link><pubDate>Wed, 23 Apr 2025 09:00:00 +0200</pubDate><guid>https://berthon.dev/posts/from-a-state-based-to-an-event-sourced-codebase/</guid><description>A few weeks ago, I&amp;rsquo;ve published a post where I described improvements for various architectures, following a logical path from a CRUD architecture to a CQRS/ES implementation.
Since then, I participated in Lyon Craft 2025, a local conference focusing on the software craftsmanship mindset and practices. For this edition, we had the pleasure to invite Jérémie Chassaing for an event-sourcing workshop. I had the opportunity to discuss with him and attend his workshop.</description></item><item><title>Designing with types</title><link>https://berthon.dev/posts/designing-with-types/</link><pubDate>Wed, 02 Apr 2025 09:00:00 +0200</pubDate><guid>https://berthon.dev/posts/designing-with-types/</guid><description>When writing software, we&amp;rsquo;re using types to represent the information we&amp;rsquo;re manipulating. Values are express through primitive types like bool, int or string. We&amp;rsquo;re building complex data representation by composing these types. This composition is done by defining our own types, usually with classes or tuples.
Even if there are several ways to store and represent the same information, these ways are not all equivalent. Some are too permissive and allows states that should be considered as illegal regarding our business rules.</description></item><item><title>Refining software architectures</title><link>https://berthon.dev/posts/refining-software-architectures/</link><pubDate>Wed, 12 Mar 2025 09:00:24 +0100</pubDate><guid>https://berthon.dev/posts/refining-software-architectures/</guid><description>To develop software, as developers we have to choose between several architectures. Our choice must be based on various constraints like the type of problem we&amp;rsquo;re trying to solve, but also the load or the level of reliability and resiliency targeted. We also have to consider the available skills in the team.
In this blog post, I want to iterate through several back-end architectures I&amp;rsquo;ve encountered and used during my career.</description></item><item><title>The "technological adulthood"</title><link>https://berthon.dev/posts/the-technological-adulthood/</link><pubDate>Wed, 19 Feb 2025 09:00:00 +0100</pubDate><guid>https://berthon.dev/posts/the-technological-adulthood/</guid><description>Few months ago, I&amp;rsquo;ve read this article: How We Built a Self-Healing System to Survive a Terrifying Concurrency Bug At Netflix.
What I loved is how unconventional the solution was. However, unconventional doesn&amp;rsquo;t mean irrelevant, their solution kept the software running during the weekend, and this without any human intervention. The solution wasn&amp;rsquo;t perfect, but it was &amp;ldquo;good enough&amp;rdquo; and even more, respectful of people&amp;rsquo;s time.
By the end, it concludes with a concept that somehow inspired me: &amp;ldquo;technological adulthood&amp;rdquo;.</description></item><item><title>Applying the '/ai manifesto'</title><link>https://berthon.dev/posts/applying-the-ai-manifesto/</link><pubDate>Wed, 05 Feb 2025 09:00:00 +0100</pubDate><guid>https://berthon.dev/posts/applying-the-ai-manifesto/</guid><description>Recently, Antoine Caron published a blog post about his AI usage. Thanks to him, I&amp;rsquo;ve discovered the /ai &amp;lsquo;manifesto&amp;rsquo; and I want to do the same here. Maybe you&amp;rsquo;ve reached this post by typing /ai in the URL.
My posts All the posts in this blog are written by myself, I don&amp;rsquo;t use any generative AI to produce content.
Creating a blog post is an interesting activity, it requires me to challenge and organize my thoughts before trying to write on a topic.</description></item><item><title>Using processes for better resilience</title><link>https://berthon.dev/posts/using-processes-for-better-resilience/</link><pubDate>Wed, 08 Jan 2025 09:00:00 +0100</pubDate><guid>https://berthon.dev/posts/using-processes-for-better-resilience/</guid><description>In early 2020, I&amp;rsquo;ve read the book Programming Elixir 1.6. At that time I had one goal: to have an introduction to the actor model with a language that supports it by design, in this case Elixir. I think it was a good read and I achieved my goal, even though I didn&amp;rsquo;t feel able to design a complete system using this pattern.
However, I realized I&amp;rsquo;m using some actor model concepts for a few years now.</description></item><item><title>CQRS/ES: How to achieve a good event granularity?</title><link>https://berthon.dev/posts/cqrs-es-how-to-achieve-a-good-event-granularity/</link><pubDate>Wed, 18 Dec 2024 09:00:00 +0100</pubDate><guid>https://berthon.dev/posts/cqrs-es-how-to-achieve-a-good-event-granularity/</guid><description>If you&amp;rsquo;ve already developed a software using the event sourcing pattern, you&amp;rsquo;ve probably faced difficulty: How-to design good events? What is a good event granularity?
Indeed it&amp;rsquo;s difficult to produce good events that will not harm our design. As a seasoned developer with event sourcing, I&amp;rsquo;m still struggling with this, even if I&amp;rsquo;ve developed several heuristics over time.
In this blog post, I will share with you these heuristics. But keep in mind this is not some kind of best practices.</description></item><item><title>Zero downtime database migration</title><link>https://berthon.dev/posts/zero-downtime-database-migration/</link><pubDate>Wed, 04 Dec 2024 09:13:43 +0100</pubDate><guid>https://berthon.dev/posts/zero-downtime-database-migration/</guid><description>Nowadays, most of the services we&amp;rsquo;re using are online and available 24/7. If, like me, you&amp;rsquo;re working on a company that provide this kind of service, you&amp;rsquo;re probably aiming for such availability. As I&amp;rsquo;ve already highlighted it, it has a huge influence on how you should code and deploy your software. Indeed, to maximize availability, you&amp;rsquo;re probably aiming for a zero downtime deployment.
Zero downtime deployment includes several topics. Today I want to focus on how to achieve a database migration without service interruption.</description></item><item><title>CQRS/ES : Nos heuristiques après plusieurs années de production</title><link>https://berthon.dev/posts/cqrs-es-nos-heuristiques-apres-plusieurs-annees-de-production/</link><pubDate>Tue, 26 Nov 2024 13:28:55 +0200</pubDate><guid>https://berthon.dev/posts/cqrs-es-nos-heuristiques-apres-plusieurs-annees-de-production/</guid><description>Nouvelle présentation, nouveau co-spreaker ! Cette fois-ci, c&amp;rsquo;est Aurélien BOUDOUX qui m&amp;rsquo;accompagne pour vous proposer un retour d&amp;rsquo;expérience sur nos années de développement avec le pattern CQRS/ES.
Fun fact : nous avons eu l&amp;rsquo;idée de ce talk parce que nos pratiques semblaient converger malgré des expériences très différentes. En construisant ce talk, nous avons découvert qu&amp;rsquo;en réalité nous avons des pratiques très différentes, et que celles-ci sont en grande partie issues de nos contextes respectifs.</description></item><item><title>State-based and event-based approaches</title><link>https://berthon.dev/posts/state-based-and-event-based-approaches/</link><pubDate>Wed, 20 Nov 2024 13:02:48 +0100</pubDate><guid>https://berthon.dev/posts/state-based-and-event-based-approaches/</guid><description>I&amp;rsquo;ve recently gave a talk with my friend Aurélien about the heuristics we&amp;rsquo;ve developed after using CQRS/ES for several years.
After our talk, we had a chat with some developers. We concluded that choosing a state-based oriented approach (like CRUD) seems to be the default solution, such choice seems to remain unchallenged. On the opposite side, choosing an event-based systems (event sourced or event driven) will very often be heavily challenged.</description></item><item><title>L'AGC : Retour sur l'ordinateur qui a amené l'humanité sur la Lune</title><link>https://berthon.dev/posts/l-agc-retour-sur-l-ordinateur-qui-a-amene-l-humanite-sur-la-lune/</link><pubDate>Sun, 05 May 2024 13:28:55 +0200</pubDate><guid>https://berthon.dev/posts/l-agc-retour-sur-l-ordinateur-qui-a-amene-l-humanite-sur-la-lune/</guid><description>Clap de fin pour cette présentation, nous avons donné notre dernière session le vendredi 26 avril à MixIT. J&amp;rsquo;ai eu grand plaisir à présenter ce sujet si particulier avec mon co-speaker Olivier PONCET.
Abstract Lundi 21 juillet 1969, l’humanité posait pour la première fois le pied sur la Lune. Cet exploit est le fruit de nombreuses avancées techniques et technologiques, notamment en électronique et dans le domaine de l’informatique alors naissant.</description></item><item><title>An enjoyable mission: return of experience</title><link>https://berthon.dev/posts/an-enjoyable-mission-return-of-experience/</link><pubDate>Thu, 01 Sep 2022 20:53:08 +0200</pubDate><guid>https://berthon.dev/posts/an-enjoyable-mission-return-of-experience/</guid><description>I had the chance to work few months in Agicap, an enterprise producing a cashflow management SAAS for businesses.
It was a great mission, my team worked a way that I consider to be, so far, the most efficient and pleasant in my career. We managed to produce value at a constant speed while keeping a full control of our code, not allowing any kind of quality depreciation over time.</description></item><item><title>Théorie des catégories : vous la connaissez déjà</title><link>https://berthon.dev/posts/theorie-des-categories-vous-la-connaissez-deja/</link><pubDate>Wed, 20 Apr 2022 09:00:00 +0200</pubDate><guid>https://berthon.dev/posts/theorie-des-categories-vous-la-connaissez-deja/</guid><description>Tout part d&amp;rsquo;un talk donné par Emilien PECOUL (aka Ouarzy). Durant ce talk, celui-ci a tenté de démontrer à son audience qu&amp;rsquo;elle connaissait déjà la plupart des concepts formulés dans la théorie des catégories. À mon sens, il y est parvenu même si ce sujet est bien trop vaste pour être abordé en seulement 45 minutes.
C&amp;rsquo;est pourquoi quelques années plus tard, il m&amp;rsquo;a proposé de le réadapter avec lui sur un format université (3 heures).</description></item><item><title>Uniformiser le code, bonne idée ?</title><link>https://berthon.dev/posts/uniformiser-le-code-une-bonne-idee/</link><pubDate>Wed, 01 Sep 2021 21:03:32 +0200</pubDate><guid>https://berthon.dev/posts/uniformiser-le-code-une-bonne-idee/</guid><description>Au cours de ma carrière, j’ai été confronté à plusieurs reprises à des clients et/ou des acteurs internes qui souhaitent assurer un haut niveau d’uniformisation sur le code des applications. Cela se traduit par des conventions de style, de nommage, et parfois même des choix plus impactant comme des frameworks ou des architectures spécifiques. Dans les cas extrêmes, les propos de ces personnes laissaient entendre le refus d’un quelconque écart avec ces règles.</description></item><item><title>Le principe DRY : Do(n’t) Repeat Yourself</title><link>https://berthon.dev/posts/le-principe-dry/</link><pubDate>Wed, 26 May 2021 21:18:59 +0200</pubDate><guid>https://berthon.dev/posts/le-principe-dry/</guid><description>Un biais cognitif et un usage erroné Les développeurs aiment bien les acronymes pour énoncer des “bonnes pratiques” (KISS, DRY, SOLID, etc…). Souvent, l’idée véhiculée par ceux-ci est très simple à appréhender.
Cependant, nous souffrons d’un biais cognitif énorme : plus une information est simple à intégrer, moins elle est remise en question / challengée. Et celle-ci est encore mieux intégrée si elle ne va pas en contradiction avec vos croyances.</description></item><item><title>Le piège des tests unitaires</title><link>https://berthon.dev/posts/le-piege-des-tests-unitaires/</link><pubDate>Thu, 04 Jun 2020 21:28:12 +0200</pubDate><guid>https://berthon.dev/posts/le-piege-des-tests-unitaires/</guid><description>Voilà maintenant plus de 5 ans que j’applique une approche TDD (test-driven development) sur l’ensemble des projets sur lesquels j’interviens. Si j’utilise toujours cette méthode, c’est parce que la présence de tests me donne confiance dans le code que j’écris :
Je m’assure qu’il fait bien ce que je souhaite. J’améliore constamment son design par du refactoring. Les tests mettent en lumière la très grande majorité des régressions que je peux introduire lors d’un refactoring ou d’une évolution.</description></item><item><title>Un code métier pur</title><link>https://berthon.dev/posts/un-code-metier-pur/</link><pubDate>Tue, 04 Feb 2020 12:46:38 +0200</pubDate><guid>https://berthon.dev/posts/un-code-metier-pur/</guid><description>Il y a quelques jours, au cours d’une discussion, on m’a demandé quelles sont les pratiques que je pousse dans une équipe dans le but d’améliorer la qualité de code. Bon nombre de pratiques comme TDD, clean code ou encore DDD et ses bounded-contexts ayant déjà été cités, j’ai donc répondu : un code métier pur, parfois appelé functional core.
Dans cet article, je pars du principe que vous faite une distinction et séparation forte entre le code métier qui répond à une logique business, et le code infra qui répond aux problématiques techniques.</description></item><item><title>À la découverte du Property Based Testing</title><link>https://berthon.dev/posts/a-la-decouverte-du-property-based-testing/</link><pubDate>Tue, 08 Jan 2019 13:17:17 +0200</pubDate><guid>https://berthon.dev/posts/a-la-decouverte-du-property-based-testing/</guid><description>Je suis un développeur convaincu par les bénéfices du TDD, je l’applique au quotidien sur les projets que me confient mes clients. Cela me permet de rapidement valider que mon code a bien le comportement attendu, de le “documenter” et décrivant un cas d’usage et de m’assurer par la suite que je n’introduis aucune régression si je modifie le code testé.
Je fais tout ceci en sachant que je choisis des cas de test qui me semblent représentatifs de l’usage de la fonction, on parle parfois d’Example Based Tests.</description></item><item><title>Vous n’êtes pas maître de votre code</title><link>https://berthon.dev/posts/vous-n-etes-pas-maitre-de-votre-code/</link><pubDate>Wed, 24 May 2017 13:30:19 +0200</pubDate><guid>https://berthon.dev/posts/vous-n-etes-pas-maitre-de-votre-code/</guid><description>J’ai récemment pu participer à un atelier animé par Romeu Mourra lors des NCrafts. Pas de technique ici, le but était de mettre en lumière des problèmes d’ordres systémiques. Pour cela, nous avons fait un Kebab Kata sous forme d’itérations aux-cours desquelles Romeu jouait le rôle du client, puis également de l’architecte. Son but était de nous faire échouer en usant de différents comportements toxiques que l’on retrouve fréquemment dans de vraies missions.</description></item><item><title>La complexité métier</title><link>https://berthon.dev/posts/la-complexite-metier/</link><pubDate>Tue, 07 Feb 2017 12:41:44 +0200</pubDate><guid>https://berthon.dev/posts/la-complexite-metier/</guid><description>Dans mon précédent article, j’ai évoqué les raisons pour lesquelles il faut s’orienter ou non vers une architecture de type CQRS. Parmi ces raisons, la première que j’ai évoqué était le niveau de complexité du métier : plus le métier est complexe, plus CQRS devient pertinent.
Seulement, comment définir et évaluer la complexité métier de son application ?
La complexité, c’est quoi ? “Complexité, n.f. : Caractère de ce qui est complexe, qui comporte des éléments divers qu’il est difficile de démêler” : définition proposée par le Larousse.</description></item><item><title>Pourquoi utiliser CQRS et ES ?</title><link>https://berthon.dev/posts/pourquoi-utiliser-cqrs-et-es/</link><pubDate>Tue, 20 Dec 2016 12:52:12 +0200</pubDate><guid>https://berthon.dev/posts/pourquoi-utiliser-cqrs-et-es/</guid><description>Actuellement, j’entend de plus en plus parler de CQRS et CQRS/ES : par mes collègues autour de la machine à café, lors d’entretiens techniques, sur Twitter, les blogs, etc.
Le principe du Command and Query Responsability Segregation (CQRS) est de séparer modèles d’écriture et modèles de lecture. L’Event Sourcing (ES) quant à lui consiste à sauvegarder des événements au lieu d’entités, pour reconstruire une entité il faut agréger des événements. Exprimés de cette façon, ces concepts semblent plutôt simples à comprendre, mais les aspects techniques peuvent vite les rendre complexes à appréhender et implémenter.</description></item><item><title>Les développeurs et le besoin métier</title><link>https://berthon.dev/posts/les-developpeurs-et-le-besoin-metier/</link><pubDate>Tue, 20 Sep 2016 18:18:51 +0200</pubDate><guid>https://berthon.dev/posts/les-developpeurs-et-le-besoin-metier/</guid><description>Développer est une tâche complexe, maintenir et faire évoluer un projet existant l’est aussi.
Une mauvaise qualité de code a de nombreux impacts négatifs : un nombre d’anomalies et de régressions affolantes, des coûts et délais exponentiels à chaque évolution, un manque de performances, voir une solution qui ne répond pas aux besoins. Le tout en sapant progressivement le moral des développeurs qui ont le malheur de travailler dans ces conditions.</description></item><item><title>Le mutation testing</title><link>https://berthon.dev/posts/le-mutation-testing/</link><pubDate>Tue, 26 Jul 2016 13:01:54 +0200</pubDate><guid>https://berthon.dev/posts/le-mutation-testing/</guid><description>J’ai récemment lu un article de l’oncle Bob Martin, il y expose sa découverte du mutation testing et semble très enthousiaste à ce sujet. J’ai donc décidé d’essayer un outil pour mieux comprendre cette démarche.
Le principe Aujourd’hui, beaucoup de projets sont réalisés en appliquant le TDD. Développer en appliquant le test first permet d’être sûr que l’on écrit uniquement le code nécessaire pour rendre un test valide.
Cependant, certains reprochent à cette méthode de mettre en évidence la présence de bugs, et non de démontrer l’absence de bug : un test qui échoue montre qu’il y a une anomalie, mais une anomalie peut exister sans qu’il n’y ait de test pour le montrer.</description></item><item><title>Mob programming : une approche d'équipe</title><link>https://berthon.dev/posts/mob-porgramming-une-approche-d-equipe/</link><pubDate>Wed, 22 Jun 2016 13:37:38 +0200</pubDate><guid>https://berthon.dev/posts/mob-porgramming-une-approche-d-equipe/</guid><description>Il y a quelques mois maintenant, j’ai eu l’occasion d’assister, grâce à un user group local, à une présentation de Sebastien Lambla. Celle-ci était intitulée Your Agile is Dead. J’avoue que je ne savais pas trop de quoi allait pouvoir traiter une présentation avec un tel nom, il s’agissait en réalité d’un retour expérience sur un projet réalisé en mob programming.
J’étais déjà convaincu par les bénéfices pour un projet d’appliquer le pair programming ainsi que les autres méthodes portées par l’Extreme Programming.</description></item><item><title>Le code, c’est mieux à deux</title><link>https://berthon.dev/posts/le-code-c-est-mieux-a-deux/</link><pubDate>Wed, 01 Jun 2016 13:52:46 +0200</pubDate><guid>https://berthon.dev/posts/le-code-c-est-mieux-a-deux/</guid><description>Parmi toutes les bonnes pratiques mises en place dans mon équipe actuelle, il y en a une que j’apprécie tout particulièrement : le pair programming. Nous l’utilisons pour plusieurs raisons :
traiter des tâches complexes faciliter les montées en compétence métier et technique des différents membres augmenter la qualité du code Je suis réellement convaincu par les avantages et les bénéfices qu’une équipe peut tirer du pair programming. Cependant, je constate que cette méthode n’est pas toujours bien comprise.</description></item><item><title>Les tests, contre vents et marées</title><link>https://berthon.dev/posts/les-tests-contre-vents-et-marees/</link><pubDate>Wed, 04 May 2016 14:07:07 +0200</pubDate><guid>https://berthon.dev/posts/les-tests-contre-vents-et-marees/</guid><description>Connaissez vous la bernache nonnette ?
Il s’agit d’une espèce d’oie vivant principalement dans les îles arctiques. La bernache est exclusivement végétarienne, et ce dès sa naissance. Le problème, c’est qu’elle a pour habitude de nicher au sommet d’une falaise pour se protéger elle et ses œufs des prédateurs terrestres. Les oisillons ne sachant pas voler avant l’âge de 40-45 jours, il faut que ceux-ci puissent descendre de la falaise pour se nourrir.</description></item><item><title>Enseigner le TDD</title><link>https://berthon.dev/posts/enseigner-le-tdd/</link><pubDate>Wed, 27 Apr 2016 14:19:48 +0200</pubDate><guid>https://berthon.dev/posts/enseigner-le-tdd/</guid><description>Cela fait maintenant un an que je travaille comme prestataire pour un grand groupe. Ma mission y est des plus critique. Elle consiste à développer et maintenir l’ensemble des projets utilisés pour la programmation d’objets connectés nécessaires à l’activité de l’entreprise.
Mon équipe est constituée de plusieurs profils : des développeurs, un product owner ainsi qu’un recetteur. Pour répondre à un fort besoin de qualité, les tests, et notamment les tests unitaires, constituent une composante majeure de notre travail.</description></item></channel></rss>