<!doctype html><html><meta charset=utf-8><meta http-equiv=Content-Security-Policy content="default-src 'none'; script-src 'none'; style-src 'self' 'sha256-hevimW2qBMcsaZR62OkETyNJKvnMSjRYOz6kIyvEFtg='; img-src 'self'; connect-src 'self'; base-uri 'self'; manifest-src 'self'; media-src 'self'"><meta http-equiv=Strict-Transport-Security content="max-age=63072000; includeSubDomains; preload"><meta http-equiv=X-Content-Type-Options content="nosniff"><meta http-equiv=Referrer-Policy content="strict-origin-when-cross-origin"><meta name=viewport content="width=device-width,initial-scale=1"><title>Les dÃ©veloppeurs et le besoin mÃ©tier Â· Romain Berthon</title>
<link rel=stylesheet href=/css/rocinante.css><link rel="shortcut icon" href=https://berthon.dev//favicon.ico><body><header><nav><a class=home href=https://berthon.dev/>â€¹ Home</a><div></div><div><a href=https://berthon.dev//tags/post>Posts</a>
<a href=https://berthon.dev//tags/talk>Talks</a>
<a href=https://berthon.dev//about>About</a></div></nav></header><main><div class=post><div class=title-group><div class=title><h1>Les dÃ©veloppeurs et le besoin mÃ©tier</h1></div><div class=date><h5>Sep 20, 2016</h5></div></div><article class=content><p>DÃ©velopper est une tÃ¢che complexe, maintenir et faire Ã©voluer un projet existant lâ€™est aussi.</p><p>Une mauvaise qualitÃ© de code a de nombreux impacts nÃ©gatifsÂ : un nombre dâ€™anomalies et de rÃ©gressions affolantes, des coÃ»ts et dÃ©lais exponentiels Ã  chaque Ã©volution, un manque de performances, voir une solution qui ne rÃ©pond pas aux besoins. Le tout en sapant progressivement le moral des dÃ©veloppeurs qui ont le malheur de travailler dans ces conditions.</p><h2 id=un-problÃ¨me-de-code>Un problÃ¨me de code</h2><p>Le mauvais code peut prendre de trÃ¨s nombreuses formes, mais on retrouve souvent certaines caractÃ©ristiquesÂ :</p><ul><li>Redondance</li><li>Faible consistance et absence de norme</li><li>Forte complexitÃ© cyclomatique</li><li>Fortes dÃ©pendances</li><li>Design chaotique</li><li>Ne rÃ©vÃ¨le pas les intentions mÃ©tier</li></ul><p>Toutes ces caractÃ©ristiques rendent le code extrÃªmement difficile Ã  lire et Ã  comprendre. Comment dÃ©terminer ce que fait le programme en lisant le codeÂ ? Comment localiser une fonctionnalitÃ©Â ?</p><p>Un autre problÃ¨me majeur est le turnover parmi les dÃ©veloppeurs qui peut gÃ©nÃ©rer dâ€™importantes pertes de connaissances sâ€™il est mal anticipÃ©Â : vous Ãªtes parfaitement incapables de faire un lien clair entre un besoin, une fonctionnalitÃ© et son implÃ©mentation.</p><p>DÃ¨s lors, la moindre modification se fait Ã  taton avec son lot de souffranceÂ : effets de bords, incomprÃ©hension du code, rÃ©gressions, etcâ€¦</p><h2 id=documenter-spÃ©cifier-recommencer>Documenter, spÃ©cifier, recommencer</h2><p>Une solution envisagÃ©e est de produire dâ€™importantes quantitÃ©s de documentation et de spÃ©cifications. Câ€™est par exemple le parti pris des projets rÃ©alisÃ©s en cycle en V. Lâ€™idÃ©e est dâ€™analyser le besoin et conceptualiser la solution Ã  produire avant les dÃ©veloppements.</p><p><img src=1.png alt="Schema explicatif du cycle en V"></p><p>Le premier problÃ¨me est que plus une erreur est introduite tÃ´t dans ce processus de documentation, plus les documents qui en dÃ©coulent sont erronÃ©s.</p><ul><li>Le pÃ©rimÃ¨tre doit donc Ãªtre figÃ©, sinonÂ :<ul><li>Les documentations sont trÃ¨s coÃ»teuses Ã  maintenir.</li><li>Les documentations deviennent rapidement obsolÃ¨tes.</li></ul></li><li>Les spÃ©cifications doivent ÃªtresÂ :<ul><li>complÃ¨tes</li><li>cohÃ©rentes</li><li>correctes</li><li>sans ambiguÃ¯tÃ©</li><li>rÃ©alisables</li></ul></li></ul><p>En principe, les dÃ©veloppeurs ne rÃ©alisent que la conception dÃ©taillÃ©e, cette solution comporte plusieurs inconvÃ©nients majeursÂ :</p><ul><li>Lâ€™architecture est imposÃ©e aux dÃ©veloppeurs, et peut ne pas Ãªtre adaptÃ©e.</li><li>Les dÃ©veloppeurs sont focalisÃ©s sur les aspects techniques de lâ€™application.</li></ul><p>Le dÃ©veloppement logiciel est une activitÃ© non-dÃ©terministe, par consÃ©quent dans la trÃ¨s grande majoritÃ© des cas les dÃ©veloppeurs rencontreront ces difficultÃ©sÂ : aucune spÃ©cification ne peut Ãªtre parfaite, il faut donc savoir improviser. Ã‰tant limitÃ©s Ã  une vision purement technique du projet, ils ne savent y rÃ©pondre que par des solutions techniques sans aucun sens. Au fil du projet, ceci pollue de plus en plus le code et gÃ©nÃ¨re des deltas qui invalident progressivement les documents de rÃ©fÃ©rence. Un code illisible, une spÃ©cification qui ne correspond pasÂ : vous avez de nouveau perdu les connaissances sur votre projet.</p><h2 id=le-code-la-seule-vÃ©ritÃ©>Le code, la seule vÃ©ritÃ©</h2><p>Sâ€™il existe une vÃ©ritÃ©, câ€™est bien celle du code. Peu importe ce qui est Ã©crit dans votre spÃ©cification, votre ordinateur appliquera ce que votre code lui dicteÂ : le code fait foi, il est lui mÃªme la spÃ©cification la plus dÃ©taillÃ©e et la plus prÃ©cise de votre programme.</p><p>Alors pourquoi ne pas lâ€™utiliser comme telÂ ? Pourquoi ne pas sâ€™efforcer Ã  produire du code facilement comprÃ©hensible, facilement modifiableÂ ? Câ€™est pourtant ceci qui caractÃ©rise un code propre. Si celui-ci est expressif, alors nâ€™importe qui (mÃªme une personne qui nâ€™est pas dÃ©veloppeur) peut le lire et comprendre les actions rÃ©alisÃ©es. Il est gÃ©nÃ©ralement accompagnÃ© dâ€™un ensemble de tests unitaires qui expriment chaque cas gÃ©rÃ©.</p><p><img src=2.png alt="Plance de &ldquo;Commit strip&rdquo;: le code est de la spÃ©cification"></p><p>On peut voir le mÃ©tier de dÃ©veloppeur de beaucoup de maniÃ¨res diffÃ©rentes, il est souvent comparÃ© Ã  celui dâ€™artisan (software craftsman), je le vois Ã©galement comme un rÃ´le de traducteur. Quand jâ€™Ã©cris du code, je traduis dans un langage comprÃ©hensible pour ma machine un besoin qui mâ€™a Ã©tÃ© exprimÃ© dans un langage quâ€™elle ne comprend pas.</p><p>Mais expliquer quelque chose que lâ€™on ne comprend pas soi-mÃªme est insensÃ©. Il est donc primordial que les dÃ©veloppeurs comprennent ce quâ€™ils dÃ©veloppent, dâ€™un point de vue technique, mais aussi dâ€™un point de vue mÃ©tier.</p><h2 id=amÃ©liorer-la-qualitÃ©>AmÃ©liorer la qualitÃ©</h2><p>Pour Ã©crire du code de qualitÃ©, il faut faire attention aux comportements, ne pas se contenter de quelque chose qui marcheÂ :</p><p><em>â€œHow it is done is as important as getting it done.â€</em> â€“ <a href=https://twitter.com/sandromancuso target=_blank>Sandro Mancuso</a></p><p>Il est donc nÃ©cessaires de maÃ®triser et appliquer avec rigueur certaines pratiques et principesÂ : <a href=https://en.wikipedia.org/wiki/Test-driven_development target=_blank>TDD</a>, <a href=https://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29 target=_blank>SOLID</a>, <a href=https://en.wikipedia.org/wiki/Single_responsibility_principle target=_blank>SRP</a>, <a href=https://en.wikipedia.org/wiki/KISS_principle target=_blank>KISS</a>, etc. Lire des livres tels que <a href=https://www.amazon.fr/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882 target=_blank>Clean Code</a> de <a href=https://twitter.com/unclebobmartin target=_blank>Robert C. Martin</a> sont une bonne faÃ§on de les aborder.</p><p>Il faut ensuite travailler sur lâ€™expressivitÃ© du code, du design. Est-ce que ma classe reprÃ©sente une notion mÃ©tierÂ ? Est-ce que ma mÃ©thode exprime une action mÃ©tier ou techniqueÂ ? Bien entendu, certaines problÃ©matiques restent purement techniques, mais elles doivent Ãªtre les plus discrÃ¨tes possibles dans le code en Ã©tant masquÃ©es derriÃ¨re des interfaces dÃ©diÃ©es.</p><p>Pour Ãªtre expressif, encore faut-il savoir quoi exprimer. La meilleure faÃ§on est de sâ€™intÃ©resser au mÃ©tier du logiciel. Discutez, mÃªme de faÃ§on informelle, avec lâ€™utilisateur final, avec le product owner, avec lâ€™expert mÃ©tierÂ : Nâ€™importe quelle personne pouvant vous aider Ã  comprendre le problÃ¨me auquel vous apportez une solution.</p><p><img src=3.png alt="Un camÃ©lÃ©on"></p><p>Une fois que vous aurez compris le mÃ©tier de vos interlocuteurs, vous serez capables dâ€™Ã©changer facilement avec eux, de challenger leurs besoins. Vous pourrez retranscrire les connaissances acquises dans votre code, celui-ci deviendra alors plus comprÃ©hensible, ses intentions seront beaucoup plus claires. En cas de doute, vous saurez Ã©galement vers qui vous tourner pour rÃ©pondre Ã  vos questions.</p><h2 id=quelques-mÃ©thodes>Quelques mÃ©thodes</h2><p>Il existe divers pratiques pour amÃ©liorer la comprÃ©hension mÃ©tier des dÃ©veloppeurs, et ainsi la qualitÃ© du code produit.</p><p>Adopter un fonctionnement agile est le premier pas. Ces mÃ©thodologies permettent de rapprocher dÃ©veloppeurs et clients dans le but de faciliter dialogues et feedbacks. Mettre en place ce fonctionnement est un prÃ©-requis Ã  un certain nombre de mÃ©thodes de conception et de dÃ©veloppement.</p><p>Le <a href=https://fr.wikipedia.org/wiki/Behavior_driven_development target=_blank>BDD</a> (<em>Behavior Driven Development</em>) est une pratique intÃ©ressante Ã  mettre en place. Il sâ€™agit dâ€™une variante du TDD qui met en avant le langage naturel et les interactions mÃ©tier au travers de features dÃ©coupÃ©es en scÃ©narios dâ€™utilisation. IdÃ©alement, la rÃ©daction de ces scÃ©narios doit se faire avec un expert mÃ©tier ou un product owner. Le dÃ©veloppeur comprend alors clairement ce quâ€™il dÃ©veloppe, et peut sâ€™appuyer sur les notions, le vocabulaire employÃ© dans ces features pour dÃ©signer son code. Cette pratique permet Ã©galement lâ€™Ã©mergence de lâ€™<em>Ubiquitous Language</em>.</p><p>Enfin, le <a href=https://en.wikipedia.org/wiki/Domain-driven_design target=_blank>Domain-Driven Design</a>. Il a Ã©tÃ© formalisÃ© pour la premiÃ¨re fois par <a href=https://twitter.com/ericevans0 target=_blank>Eric Evans</a> dans son <a href=https://www.amazon.fr/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215 target=_blank>blue book</a> qui prÃ©sente un ensemble de patterns tactiques et techniques. Ces patterns couvrent lâ€™ensemble du cycle de vie dâ€™un projetÂ : des mÃ©thodologies pour comprendre et reprÃ©senter un mÃ©tier, des choix dâ€™architecture, de design, etc. Lâ€™idÃ©e est de produire une architecture qui prÃ©sente de maniÃ¨re pratique plus que purement exhaustive les diffÃ©rents composants et interactions dâ€™un domaine. Les points de complexitÃ© dâ€™un logiciel doivent alors Ãªtres des points de complexitÃ© mÃ©tier et non techniques. Lâ€™arrivÃ©e de nouvelles pratiques comme lâ€™event storming, ou dâ€™architectures logiciel comme CQRS/ES dÃ©coulent directement du DDD.</p><h2 id=pour-quels-rÃ©sultats>Pour quels rÃ©sultats</h2><p>Dans mon Ã©quipe actuelle, nous nous efforÃ§ons chaque jour dâ€™appliquer ces principes et ces mÃ©thodes avec rigueur. Les bÃ©nÃ©fices de ce travail se ressentent petit Ã  petit.</p><p>La qualitÃ© de notre code augmente, le nombre dâ€™anomalies est quasiment nulle. Ã‰tant bien dÃ©couplÃ©, et ainsi ne souffrant pas dâ€™une forte complexitÃ©, notre code est Ã©galement Ã©volutif et peut subir rapidement des modifications qui peuvent Ãªtre majeures.</p><p>Notre code fait foiÂ : en cas dâ€™un doute sur une question mÃ©tier, le rÃ©flexe de tous (mÃªme celui du product owner) est de regarder le code. Nos documentations ne servent quâ€™Ã  formaliser les futurs dÃ©veloppements, et dans de rares cas Ã  sâ€™assurer quâ€™un morceau de code est bien conforme.</p><p>Merci Ã  <a href=https://twitter.com/Ouarzy target=_blank>Ouarzy</a> et <a href=https://twitter.com/nadegerouelle target=_blank>NadÃ¨ge</a> pour leurs retours.</p><hr><h2 id=commentaires>Commentaires</h2><p>Envie de commenter ? Sâ€™il vous plaÃ®t, ajoutez votre commentaire en m&rsquo;<a href="https://github.com/RomainTrm/Blog?tab=readme-ov-file#how-to-comment" target=_blank>envoyant une pull request</a>.</p></article><div class=tags><span title=Tags>ğŸ·</span><div class="horizontal-links links"><a href=/tags/post/>Post</a><a href=/tags/fr/>Fr</a></div></div></article></main><footer><div class=content-container><div class=content><div class=about><h2>Romain Berthon</h2>Software developer, *DD and F# enthusiast<p class=horizontal-links><a href=https://github.com/RomainTrm target=_blank>Github</a><a href=https://bsky.app/profile/berthon.dev target=_blank>Bsky</a><a href=https://fr.linkedin.com/in/romain-berthon-254977101 target=_blank>LinkedIn</a></p></div></div></div></footer></body></html>