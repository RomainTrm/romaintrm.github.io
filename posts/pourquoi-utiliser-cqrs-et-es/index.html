<!DOCTYPE html>
<html><meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Pourquoi utiliser CQRS et ES ? Â· Romain Berthon</title>



<link rel="stylesheet" href="/css/rocinante.css" />
<link rel="shortcut icon" href="favicon.ico">


<body>
    <header><nav>
  
    <a class="home" href="https://berthon.dev/">â€¹ Home</a>
  
  <div></div>
  <div>
    <a href="https://berthon.dev//tags/post">Posts</a>
    <a href="https://berthon.dev//tags/talk">Talks</a>
    
      <a href="https://berthon.dev//about">About</a>
    
  </div>
</nav>
</header>
    <main>

    <div class="post">
        <div class="title-group">
            <div class="title">
                <h1>Pourquoi utiliser CQRS et ES ?</h1>
            </div>
            <div class="date"><h5>Dec 20, 2016</h5></div>
        </div>
        <article class="content">
            <p>Actuellement, jâ€™entend de plus en plus parler de CQRS et CQRS/ESÂ : par mes collÃ¨gues autour de la machine Ã  cafÃ©, lors dâ€™entretiens techniques, sur Twitter, les blogs, etc.</p>
<p><img src="1.png" alt="Tampon &ldquo;Must have&rdquo;"></p>
<p>Le principe du <em>Command and Query Responsability Segregation</em> (CQRS) est de sÃ©parer modÃ¨les dâ€™Ã©criture et modÃ¨les de lecture. Lâ€™<em>Event Sourcing</em> (ES) quant Ã  lui consiste Ã  sauvegarder des Ã©vÃ©nements au lieu dâ€™entitÃ©s, pour reconstruire une entitÃ© il faut agrÃ©ger des Ã©vÃ©nements. ExprimÃ©s de cette faÃ§on, ces concepts semblent plutÃ´t simples Ã  comprendre, mais les aspects techniques peuvent vite les rendre complexes Ã  apprÃ©hender et implÃ©menter.</p>
<p>Alors pourquoi choisir de modifier la faÃ§on dont nous reprÃ©sentons nos modÃ¨les de donnÃ©esÂ ?</p>
<p>Si vous lisez attentivement un livre sur le <em><a href="https://en.wikipedia.org/wiki/Domain-driven_design" target="_blank">Domain Driven Design</a></em> (dont dÃ©coule CQRS et ES), la rÃ©ponse que vous obtiendrez seraÂ : tout dÃ©pend de votre mÃ©tier et de vos besoins.</p>
<h2 id="prendre-une-dÃ©cision-et-dÃ©crire-un-changement">Prendre une dÃ©cision et dÃ©crire un changement</h2>
<p>Pour comprendre un des avantages de CQRS, il faut se focaliser sur notre mode dâ€™expression oral.</p>
<p>Imaginons quâ€™Ã  un instant T je rÃ©side Ã  lâ€™adresse A, puis je dÃ©mÃ©nage Ã  lâ€™adresse B. On peut dire quâ€™Ã  T+1 je rÃ©side Ã  lâ€™adresse B.</p>
<p>Ici je reprÃ©sente une entitÃ© et mon adresse est une de mes propriÃ©tÃ©s. Un systÃ¨me de type CRUD (<em>Create Request Update Delete</em>) remplace mon adresse A par une adresse B, ce qui est fondamentalement vrai et simple Ã  comprendre dans cet exemple. Cependant, le CRUD impose de me connaÃ®tre en tant quâ€™entitÃ©Â : mon adresse nâ€™est sans doute pas la seule chose qui me caractÃ©rise, on peut penser Ã  mon nom, prÃ©nom, Ã¢ge, sexe, taille, poids, etc. On observe une forte complexitÃ© accidentelle pour un changement dâ€™Ã©tat qui est pourtant simple. Mon poids nâ€™a pas dâ€™influence sur le choix de ma nouvelle adresse mais il est connu, et il doit Ãªtre fourni lors de mon changement dâ€™Ã©tat.</p>
<p>De plus, avec le CRUD je ne mets pas rÃ©ellement en avant lâ€™action qui me fait changer dâ€™adresseÂ : mon dÃ©mÃ©nagement. Les deux informations nÃ©cessaires pour me faire dÃ©mÃ©nager sont mon identitÃ© et ma nouvelle adresseÂ : ceci est ma commande â€œdÃ©mÃ©nageâ€ dans une architecture CQRS. Ensuite, mon identitÃ© et mon adresse actuelle sont sans doute les seuls Ã©lÃ©ments nÃ©cessaires pour prendre la dÃ©cision de dÃ©mÃ©nager. Câ€™est une description partielle de mon Ã©tat, mais adaptÃ©e Ã  ma prise de dÃ©cision, ceci est ma query dans une architecture CQRS.</p>
<p>Vu de cette faÃ§on, le CQRS semble donc plus proche de la faÃ§on dont nous raisonnons naturellement. On peut donc facilement exprimer les gestes mÃ©tiers issus de lâ€™<em>Ubiquitous Language</em> dans le code. Cette approche sâ€™adapte bien avec une pratique comme le <em>Behavior Driven Development</em> (<a href="https://fr.wikipedia.org/wiki/Behavior_driven_development" target="_blank">BDD</a>), une action dÃ©crite dans un scÃ©nario de test se traduit naturellement par un commande envoyÃ©e au systÃ¨me.</p>
<p>Alors CRUD ou CQRSÂ ? Quel est le niveau de complexitÃ© de votre mÃ©tierÂ ? Voici une rÃ©ponse possibleÂ :</p>
<table>
<thead>
<tr>
<th>ComplexitÃ© mÃ©tier / Architecture</th>
<th>Simple</th>
<th>Complexe</th>
</tr>
</thead>
<tbody>
<tr>
<td>CRUD</td>
<td>AdaptÃ©</td>
<td>ComplexitÃ© accidentelle</td>
</tr>
<tr>
<td>CQRS</td>
<td>Sur-qualitÃ©</td>
<td>AdaptÃ©</td>
</tr>
</tbody>
</table>
<h2 id="la-mÃ©moire-des-actions">La mÃ©moire des actions</h2>
<p>Est-il important de savoir quelles actions ont Ã©tÃ© menÃ©es sur votre systÃ¨meÂ ? Cela peut Ãªtre le cas dans certains mÃ©tiers comme le e-commerceÂ : ceci permet par exemple de savoir quels articles ont pu Ãªtre ajoutÃ©s au panier puis retirÃ©s, et ainsi cibler les suggestions pour un client donnÃ©.</p>
<p>Le problÃ¨me dâ€™un systÃ¨me de persistance par Ã©tat (utilisation dâ€™entitÃ©s) est quâ€™il nâ€™y a pas dâ€™historique des Ã©tats prÃ©cÃ©dents. En suivant cette logique pour mon dÃ©mÃ©nagement, je sais Ã  lâ€™instant T je rÃ©side Ã  lâ€™adresse A. Ã€ lâ€™instant T+1 je rÃ©side Ã  lâ€™adresse B mais je nâ€™ai aucune trace dâ€™un changement dâ€™adresse.</p>
<p>Pourtant si vous me posez la question lors dâ€™une conversation, je vais Ãªtre capable de vous dire que je rÃ©sidais Ã  lâ€™adresse A Ã  lâ€™instant T, et que maintenant en T+1 je rÃ©side Ã  lâ€™adresse B parce que jâ€™ai dÃ©mÃ©nagÃ© entre temps. Notre mÃ©moire fonctionne Ã  la faÃ§on de lâ€™<em>event sourcing</em>. Je retiens les Ã©vÃ©nements qui me sont arrivÃ©s et grÃ¢ce Ã  eux je peux restituer mes Ã©tats aux instants T et T+1.</p>
<p><img src="2.png" alt="Pile d&rsquo;Ã©vÃ©nements"></p>
<p>LÃ  encore, cette pratique sâ€™adapte bien au BDD. Quand vous dÃ©finissez lâ€™Ã©tat de votre systÃ¨me, vous dÃ©crivez les Ã©vÃ©nements qui se sont produits.</p>
<p>Pour tester une architecture CQRS/ES avec le BDD, vous ajoutez donc un ensemble dâ€™Ã©vÃ©nements dans votre <em>event store</em>. Puis vous lancez une commande et vous vÃ©rifiez ensuite le comportement attendu (levÃ© dâ€™une exception, mise Ã  jour des projections, etc.). Tester ce type dâ€™architecture avec une approche mÃ©tier est par consÃ©quent trÃ¨s simple avec le langage naturel.</p>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Gherkin" data-lang="Gherkin"><span style="display:flex;"><span><span style="color:#00a8c8">Scenario:</span><span style="color:#75af00"> Add units to an item
</span></span></span><span style="display:flex;"><span><span style="color:#75af00"></span><span style="color:#00a8c8">    Given </span><span style="color:#75af00">I created an item &#34;</span><span style="color:#d88200">chair</span><span style="color:#75af00">&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75af00">    </span><span style="color:#00a8c8">And </span><span style="color:#75af00">I added </span><span style="color:#d88200">5</span><span style="color:#75af00"> units
</span></span></span><span style="display:flex;"><span><span style="color:#75af00">    </span><span style="color:#00a8c8">When </span><span style="color:#75af00">I add </span><span style="color:#d88200">3</span><span style="color:#75af00"> units
</span></span></span><span style="display:flex;"><span><span style="color:#75af00">    </span><span style="color:#00a8c8">Then </span><span style="color:#75af00">I can see &#34;</span><span style="color:#d88200">chair</span><span style="color:#75af00">&#34; item with </span><span style="color:#d88200">8</span><span style="color:#75af00"> units in my items list
</span></span></span></code></pre></div><p>Un autre avantage de lâ€™event sourcing est quâ€™il facilite la communication entre plusieurs contextes. Un <em><a href="http://martinfowler.com/bliki/BoundedContext.html" target="_blank">bounded context</a></em> peut Ã©mettre un Ã©vÃ©nement dans un <em>event bus</em>, tous les <em>bounded contexts</em> qui attendent ce type dâ€™Ã©vÃ©nement le rÃ©cupÃ©reront et lâ€™appliqueront Ã  leurs propres modÃ¨les. Pour autant, il nâ€™est pas nÃ©cessaire que ces deux contextes utilisent lâ€™ES, une simple couche dâ€™anti-corruption peut permettre dâ€™interfacer un systÃ¨me de type CRUD.</p>
<h2 id="gagner-en-performance-et-en-robustesse">Gagner en performance et en robustesse</h2>
<p>Votre systÃ¨me a-t-il des attentes Ã©levÃ©es en terme de performanceÂ ? On peut par exemple imaginer un site de billetterie en ligne, Ã  lâ€™annonce dâ€™une date importante, celui-ci risque dâ€™Ãªtre pris dâ€™assaut par les utilisateurs et nÃ©cessitent donc dâ€™Ãªtre robustes et rapides.</p>
<p>La majoritÃ© des systÃ¨mes ont un ratio lecture/Ã©criture trÃ¨s dÃ©sÃ©quilibrÃ©, avec un nombre de lectures bien supÃ©rieur au nombre dâ€™Ã©critures. GÃ©rer les relations entre plusieurs entitÃ©s, notamment Ã  lâ€™aide de jointures, peut nÃ©cessiter dâ€™importantes ressources et provoquer des latences.</p>
<p>Câ€™est lÃ  lâ€™un des autres avantages de CQRS, produire des modÃ¨les de lectures dÃ©diÃ©es permet des requÃªtes rapides sans jointure. Chaque vue de votre application ne doit dÃ©pendre que dâ€™un seul modÃ¨le de lecture, et ainsi effectuer une requÃªte sur une seule table pour obtenir lâ€™ensemble des informations qui lui sont nÃ©cessaires.</p>
<p>Pour rendre plus rapidement la main Ã  lâ€™utilisateur suite Ã  lâ€™exÃ©cution dâ€™une commande, la mise Ã  jour des modÃ¨les de lecture peut se faire de maniÃ¨re asynchrone. Il peut alors Ãªtre nÃ©cessaire de mettre Ã  jour les informations affichÃ©es pour assurer la cohÃ©rence des donnÃ©es avant que la commande ne soit rÃ©ellement appliquÃ©e au modÃ¨les de lectures.</p>
<p>Lâ€™<em>event sourcing</em> permet Ã©galement des gains de performance et de robustesse. Je parle ici du nombre dâ€™opÃ©rations menÃ©es sur la base dâ€™Ã©criture. Un Ã©vÃ©nement est un fait, il sâ€™est produit et est irrÃ©vocable. Chaque Ã©vÃ©nement est indÃ©pendant des autres, il nâ€™existe donc aucune forme de relation entre les Ã©vÃ©nements dans la base de donnÃ©es. On ne peut donc quâ€™Ã©crire des nouveaux Ã©vÃ©nements ou faire des lectures pour gÃ©nÃ©rer des agrÃ©gats.</p>
<p>Les Ã©vÃ©nements suppriment Ã©galement un problÃ¨me inhÃ©rent aux modÃ¨les de donnÃ©es relationnelsÂ : vous allez devoir insÃ©rer ou mettre Ã  jour plusieurs objets dans des <em>repositories</em> diffÃ©rents. Une Ã©criture / mise Ã  jour des donnÃ©es peut Ã©chouer en cours dâ€™exÃ©cution, pour Ã©viter une donnÃ©e partiellement enregistrÃ©, il faut alors mettre en place des systÃ¨mes de contextes. Ces mÃ©canismes sont lourds Ã  mettre en place et Ã  gÃ©rer, ils ajoutent Ã©galement une forte complexitÃ© accidentelle. Lâ€™ES vous affranchit des problÃ¨mes de cohÃ©rence des donnÃ©es en cas dâ€™erreur lors de la persistanceÂ : lâ€™Ã©criture de votre Ã©vÃ©nement fonctionne ou non.</p>
<h2 id="pour-conclure">Pour conclure</h2>
<p>Bien que CQRS et CQRS/ES soient les nouvelles architectures â€œÃ  la modeâ€, on constate quâ€™il ne sâ€™agit pas de <em>silver bullets</em>Â : elles rÃ©pondent Ã  des problÃ©matiques prÃ©cises. Il est donc important de clairement identifier ses besoins avant de se tourner vers ces architectures. Si vous choisissez de les utiliser, il ne faut pas les craindreÂ : si celles-ci sont plus complexes Ã  apprÃ©hender quâ€™une architecture en couche de type CRUD, les bÃ©nÃ©fices compensent le coÃ»t initial de mise en place.</p>
<p>Merci Ã  <a href="https://twitter.com/nadegerouelle" target="_blank">NadÃ¨ge</a> pour ses retours.</p>
<hr>
<h2 id="commentaires">Commentaires</h2>
<!--Ajoutez votre commentaire ici-->
<p>Envie de commenter ? Sâ€™il vous plaÃ®t, ajoutez votre commentaire en m&rsquo;<a href="https://github.com/RomainTrm/Blog?tab=readme-ov-file#how-to-comment" target="_blank">envoyant une pull request</a>.</p>

        </article>
        
            <div class="tags">
                <span title="Tags">ğŸ·</span>
                <div class="horizontal-links links">
                    <a href="/tags/post/">Post</a><a href="/tags/fr/">Fr</a>
                </div>
            </div>
        
    </article>


    </main>
    <footer>
  <div class="content-container">
    <div class="content"><div class="about">
  <h2>Romain Berthon</h2>
  Software developer, *DD and F# enthusiast

  
    <p class="horizontal-links"><a href="https://github.com/RomainTrm"
         target="_blank" 
        
        >Github</a><a href="https://bsky.app/profile/romaintrm.bsky.social"
         target="_blank" 
        
        >Bsky</a><a href="https://fr.linkedin.com/in/romain-berthon-254977101"
         target="_blank" 
        
        >LinkedIn</a></p>
  
</div>
</div>
  </div>
</footer>
    
    <script>
      const emailId = atob("");
    </script></body>
</html>
